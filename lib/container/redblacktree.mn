/**
 * This module provides the {RedBlackTree} class which is a low level class to
 * store and search ordered elements.
 */

load mint.lang
load mint.operator
load mint.garbagecollector

/**
 * This class create a self-balancing binary search tree. Each node stores a
 * {RedBlackTree.Color}, used to ensure that the tree remains approximately
 * balanced during insertions and deletions.
 * 
 * Each node of the tree store a key value. A `comparator` function must be
 * provided to the class instances to be used to sort keys. The values used
 * as key in the instances must provide the operator used by the function.
 */
class RedBlackTree {
	/**
	 * The color of a node used to ensure that the tree remains approximately
 	 * balanced during insertions and deletions.
	 */
	enum Color {
		/// The node is red.
		Red
		/// The node is black.
		Black
	}

	/**
	 * Creates a new instance of {RedBlackTree}. The `comparator` function can
	 * be overloaded to change the key sorting behaviour of the tree. By
	 * default, the same behaviour than the `hash` keys is used.
	 */
	const def new(self, comparator = hashKeyCompareOperator) {
		self.comparator = comparator
		return self
	}

	/**
	 * Cleans up the tree instance.
	 */
	const def delete(self) {
		GarbageCollector.collect()
	}

	/**
	 * Returns the comparator function used by the tree.
	 */
	const def getComparator(const self) {
		return self.comparator
	}

	/**
	 * Inserts `key` in the tree. If `key` is already contained in the tree,
	 * this method has no effect.
	 */
	const def insert(self, key) {
		var node = RedBlackTree.Node(RedBlackTree.Color.Red, key)
		if self.root is null {
			self.root = node
		} else {
			self.root = self.root.insert(node, self.comparator)
		}
	}

	/**
	 * Removes the element associated to the specified `key` in the tree.
	 * 
	 * If `key` is not contained in the tree, `false` is returned; otherwise
	 * `true` is returned.
	 */
	const def remove(self, key) {
		if self.root {
			if isDefined(node = self.root.find(key, self.comparator)) {
				self.root = node.deleteOneChild()
				return true
			}
		}
		return false
	}

	/**
	 * Returns the value `key` in the tree.
	 * 
	 * If `key` is not contained in the tree, `none` is returned instead.
	 */
	const def find(const self, key) {
		var node = none
		if self.root {
			node = self.root.find(key, self.comparator)
		}
		if defined node {
			return node.getKey()
		}
	}

	/**
	 * Apply the `func` function to each elements of the tree.
	 */
	const def each(const self, func) {
		if self.root {
			self.root.each(func)
		}
	}

	/**
	 * Returns `true` if the tree is empty; otherwise returns `false`.
	 */
	const def isEmpty(const self) {
		return self.root is null
	}

	/**
	 * This class describe a node of the tree. A node store a color and a key
	 * value.
	 */
	- class Node {
		/**
		 * Creates a new node with the color `color` and the value `key`.
		 */
		const def new(self, color, key) {
			self.color = color
			self.key = key
			return self
		}

		/**
		 * Returns the key value of the node.
		 */
		const def getKey(const self) {
			return self.key
		}

		/**
		 * Returns the parent node of the node or `null` if the node is the root
		 * node.
		 */
		const def getParent(const self) {
			return self.parent
		}

		/**
		 * Returns the parent of this node's parent or `null` if this node or his
		 * parent is the root node.
		 */
		const def getGrandParent(const self) {
			return self.parent ? self.parent.parent : null
		}

		/**
		 * Returns the sibling node of this node or `null` if this node has no
		 * sibling. The sibling node is the other child node of this node
		 * parent.
		 */
		const def getSibling(const self) {
			if p = self.parent {
				if self is p.left {
					return p.right
				} else {
					return p.left
				}
			}
			return null
		}

		/**
		 * Returns the uncle node of this node or `null` if this node has no
		 * uncle. The uncle node is the other child node of the parent node
		 * of this node's parent.
		 */
		const def getUncle(const self) {
			if self.parent {
				return self.parent.getSibling()
			}
		}

		/**
		 * Searchs recursively for a node with a key value that match `key`
		 * using the `comparator` function. The `comparator` function must
		 * return `true` if the first parameter value is less tahn the second
		 * parameter value.
		 * 
		 * Returns the first node that have a match or `none` if no node was
		 * found.
		 */
		const def find(const self, key, comparator) {
			switch (number(comparator(self.key, key)) - number(comparator(key, self.key))) {
			case 0:
				return self
			case 1:
				if self.left {
					return self.left.find(key, comparator)
				}
				break
			case -1:
				if self.right {
					return self.right.find(key, comparator)
				}
				break
			}
		}

		/**
		 * Applies recursively the `func` function to the key value of each
		 * node.
		 */
		const def each(const self, func) {
			if self.right {
				self.right.each(func)
			}
			func(self.key)
			if self.left {
				self.left.each(func)
			}
		}

		/**
		 * Rotates the node to the left.
		 */
		const def rotateLeft(self) {
			var nnew = self.right
			var p = self.getParent()
			
			self.right = nnew.left
			nnew.left = self
			self.parent = nnew
			
			// Handle other child/parent pointers.
			if self.right {
				self.right.parent = self
			}

			// Initially self could be the root.
			if p {
				if self is p.left {
					p.left = nnew
				} elif self is p.right {
					p.right = nnew
				}
			}
			
			nnew.parent = p
		}

		/**
		 * Rotates the node to the right.
		 */
		const def rotateRight(self) {
			var nnew = self.left
			var p = self.parent

			self.left = nnew.right
			nnew.right = self
			self.parent = nnew

			// Handle other child/parent pointers.
			if self.left {
				self.left.parent = self
			}

			// Initially self could be the root.
			if p {
				if self is p.left {
					p.left = nnew
				} elif self is p.right {
					p.right = nnew
				}
			}
			
			nnew.parent = p
		}
		
		/**
		 * Inserts the `node` new node under this node. The `comparator`
		 * function is used to sort the newly inserted node.
		 * 
		 * Returns the new root node of the tree.
		 */
		const def insert(self, node, comparator) {
			// Insert new Node into the current tree.
			if self.insertRecurse(node, comparator) {
				// Repair the tree in case any of the red-black properties have been violated.
				self.insertRepairTree()
				root = node
			} else {
				root = self
			}
			// Find the new root to return.
			while root.parent {
				root = root.parent
			}
			return root
		}

		/**
		 * Tries recursively to insert the `node` new node in the tree
		 * using the `comparator` function. The `comparator` function must
		 * return `true` if the first parameter value is less tahn the second
		 * parameter value.
		 * 
		 * Returns `true` if the node can be inserted in the tree; otherwise
		 * returns `false` and the node is not inserted.
		 */
		- const def insertRecurse(self, node, comparator) {
			// Recursively descend the tree until a leaf is found.
			switch (number(comparator(self.key, node.key)) - number(comparator(node.key, self.key))) {
			case 0:
				return false
			case 1:
				if self.left {
					return self.left.insertRecurse(node, comparator)
				}
				self.left = node
				node.parent = self
				return true
			case -1:
				if self.right {
					return self.right.insertRecurse(node, comparator)
				}
				self.right = node
				node.parent = self
				return true
			}
		}

		/**
		 * Repaires the tree after an insertion.
		 */
		- const def insertRepairTree(self) {
			if self.parent is null {
				self.insertCase1()
			} elif self.parent.color is RedBlackTree.Color.Black {
				self.insertCase2()
			} elif self = self.getUncle() and self.color is RedBlackTree.Color.Red {
				self.insertCase3()
			} else {
				self.insertCase4()
			}
		}

		/**
		 * Repaires after insertion case 1 : .
		 */
		- const def insertCase1(self) {
			self.color = RedBlackTree.Color.Black
		}

		/**
		 * Repaires after insertion case 2 : .
		 */
		- const def insertCase2(self) {
			return none
		}

		/**
		 * Repaires after insertion case 3 : .
		 */
		- const def insertCase3(self) {
			self.parent.color = RedBlackTree.Color.Black
			self.getUncle().color = RedBlackTree.Color.Black
			self.getGrandParent().color = RedBlackTree.Color.Red
			self.getGrandParent().insertRepairTree()
		}

		/**
		 * Repaires after insertion case 4 : .
		 */
		- const def insertCase4(self) {
			var p = self.parent
			var g = self.getGrandParent()

			if self is p.right and p is g.left {
				p.rotateLeft()
				self = self.left
			} elif self is p.left and p is g.right {
				p.rotateRight()
				self = self.right
			}

			self.insertCase5()
		}

		/**
		 * Repaires after insertion case 5 : .
		 */
		- const def insertCase5(self) {
			var p = self.parent
			var g = self.getGrandParent()

			if self is p.left {
				g.rotateRight()
			} else {
				g.rotateLeft()
			}
			
			p.color = RedBlackTree.Color.Black
			g.color = RedBlackTree.Color.Red
		}

		/**
		 * Deletes the last child of this node.
		 */
		const def deleteOneChild(self) {

			// Precondition: self has at most one non-leaf child
			if child = (self.right is null) ? self.left : self.right {
				if self.parent {
					self.replaceChild(child)
				} else {
					child.parent = null
				}
				if self.color is RedBlackTree.Color.Black {
					if child.color is RedBlackTree.Color.Red {
						child.color = RedBlackTree.Color.Black
					} else {
						child.deleteCase1()
					}
				}
				root = child
			} elif self.parent {
				if self is self.parent.left {
					self.parent.left = null
				} else {
					self.parent.right = null
				}
				root = self.parent
			} else {
				return null
			}

			// Find the new root to return.
			while root.parent {
				root = root.parent
			}
			return root
		}

		/**
		 * Replaces this node by child.
		 */
		const def replaceChild(self, child) {
			child.parent = self.parent
			if self is self.parent.left {
				self.parent.left = child
			} else {
				self.parent.right = child
			}
		}

		/**
		 * Repaires after deletion case 1 : .
		 */
		- const def deleteCase1(self) {
			if self.parent {
				self.deleteCase2()
			}
		}

		/**
		 * Repaires after deletion case 2 : .
		 */
		- const def deleteCase2(self) {
			var s = self.getSibling()

			if s.color is RedBlackTree.Color.Red {
				self.parent.color = RedBlackTree.Color.Red
				s.color = RedBlackTree.Color.Black
				if self is self.parent.left {
					self.parent.rotateLeft()
				} else {
					self.parent.rotateRight()
				}
			}
			self.deleteCase3()
		}

		/**
		 * Repaires after deletion case 3 : .
		 */
		- const def deleteCase3(self) {
			var s = self.getSibling()

			if ((self.parent.color is RedBlackTree.Color.Black) && (s.color is RedBlackTree.Color.Black) && (s.left.color is RedBlackTree.Color.Black) && (s.right.color is RedBlackTree.Color.Black)) {
				s.color = RedBlackTree.Color.Red
				self.parent.deleteCase1()
			} else {
				self.deleteCase4()
			}
		}

		/**
		 * Repaires after deletion case 4 : .
		 */
		- const def deleteCase4(self) {
			var s = self.getSibling()

			if ((self.parent.color is RedBlackTree.Color.Red) && (s.color is RedBlackTree.Color.Black) && (s.left.color is RedBlackTree.Color.Black) && (s.right.color is RedBlackTree.Color.Black)) {
				s.color = RedBlackTree.Color.Red
				self.parent.color = RedBlackTree.Color.Black
			} else {
				self.deleteCase5()
			}
		}

		/**
		 * Repaires after deletion case 5 : .
		 */
		- const def deleteCase5(self) {
			var s = self.getSibling()

			// This if statement is trivial, due to case 2 (even though case 2 changed
			// the sibling to a sibling's child, the sibling's child can't be red, since
			// no red parent can have a red child).
			if s.color is RedBlackTree.Color.Black {
				// The following statements just force the red to be on the left of the
				// left of the parent, or right of the right, so case six will rotate
				// correctly.
				if ((self is self.parent.left) && (s.right.color is RedBlackTree.Color.Black) && (s.left.color is RedBlackTree.Color.Red)) {
					// This last test is trivial too due to cases 2-4.
					s.color = RedBlackTree.Color.Red
					s.left.color = RedBlackTree.Color.Black
					s.rotateRight()
				} elif ((self is self.parent.right) && (s.left.color is RedBlackTree.Color.Black) && (s.right.color is RedBlackTree.Color.Red)) {
					// This last test is trivial too due to cases 2-4.
					s.color = RedBlackTree.Color.Red
					s.right.color = RedBlackTree.Color.Black
					s.rotateLeft()
				}
			}
			self.deleteCase6()
		}

		/**
		 * Repaires after deletion case 6 : .
		 */
		- const def deleteCase6(self) {
			var s = self.getSibling()

			s.color = self.parent.color
			self.parent.color = RedBlackTree.Color.Black

			if self is self.parent.left {
				s.right.color = RedBlackTree.Color.Black
				self.parent.RotateLeft()
			} else {
				s.left.color = RedBlackTree.Color.Black
				self.parent.rotateRight()
			}
		}

		/// Internal parent node.
		- parent = null

		/// Internal left child node.
		- left = null

		/// Internal right child node.
		- right = null

		/// Internal color.
		- color = none

		/// Internal key value.
		- key = none
	}

	/// Internal comparator function.
	- comparator = none

	/// Internal root node.
	- root = null
}
