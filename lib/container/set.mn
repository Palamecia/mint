/**
 * This module provides the {Set} class which store unique objects and provides
 * fast lookup of a value.
 */

load mint.type
load exception.container
load container.redblacktree

/**
 * This class create a set based on {RedBlackTree} which stores a liste
 * of unique values.
 * 
 * When iterating over a {Set}, the elements are always sorted. A `comparator`
 * function must be provided to the class instances to be used to sort values.
 * The values inserted in the instances must provide the operator used by the
 * function.
 */
class Set {
	/**
	 * Creates a new instance of {Set}. If `values` is given, the set will be
	 * initialized with the given values. The `comparator` function can be
	 * overloaded to change the value sorting behaviour of the set. By default,
	 * the same behaviour than the `hash` keys is used.
	 */
	const def new(self, values = (), comparator = hashKeyCompareOperator) {
		self.root = RedBlackTree(comparator)
		for value in array(values) {
			self.insert(value)
		}
		return self
	}

	/**
	 * Returns an `iterator` on each element of the set.
	 */
	const def in(const self) {
		for value in self.values() {
			yield value
		}
	}

	/**
	 * Returns `true` if the set contains the `value` value; otherwise returns
	 * `false`.
	 */
	const def in(const self, const value) {
		var node = self.root.find(value)
		return defined node
	}

	/**
	 * Apply the `func` function to each elements of the set.
	 */
	const def each(const self, func) {
		self.root.each(def [func] (item) {
			func(item)
		})
	}

	/**
	 * Returns an `array` containing each elements of the set.
	 */
	const def values(const self) {
		var values = []
		self.root.each(def [values] (item) {
			values << item
		})
		return values
	}

	/**
	 * Converts the set to an `array`.
	 */
	const def toArray(const self) {
		return self.values()
	}

	/**
	 * Inserts `value` in the set. If `value` is already contained in the set,
	 * this method has no effect.
	 */
	const def insert(self, value) {
		self.root.insert(value)
	}

	/**
	 * Removes `value` from the set.
	 * 
	 * If `value` is not contained in the set, `false` is returned; otherwise
	 * `true` is returned.
	 */
	const def remove(self, value) {
		return self.root.remove(value)
	}

	/**
	 * Removes all the elements of the set.
	 */
	const def clear(self) {
		self.root = RedBlackTree()
	}

	/**
	 * Returns the number of elements in the set.
	 */
	const def size(const self) {
		var count = 0
		self.root.each(def [count] (item) {
			count := count + 1
		})
		return count
	}

	/**
	 * Returns `true` if the set is empty; otherwise returns `false`.
	 */
	const def isEmpty(const self) {
		return self.root.isEmpty()
	}

	/// Root element node.
	- root = null
}
