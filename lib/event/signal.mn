/**
 * This module provides the {Event.Signal} class which provides an evenemential
 * callback mechanisme.
 */

load mint.function

package Event {
	/**
	 * This class provides an evenemential callback mechanisme. Multiple
	 * callbacks can be connected to an instance using the {@see connect}
	 * method. Each connected callback will then be called on a call to the
	 * {@see ()} operator.
	 * 
	 * This class is not compatible with {Event.Watcher}.
	 */
	class Signal {
		/**
		 * Creates a new signal.
		 */
		def new(self) {
			return self
		}

		/**
		 * Connects the signal to the given `func` function. The `func`
		 * function can either be a `function` or an instane of {Callback}.
		 * 
		 * Returns `true` if the function was correctly connected to the signal;
		 * otherwise returs `false`.
		 */
		def connect(self, func) {
			if func not in self.slots {
				self.slots << func
				return true
			}
			return false
		}

		/**
		 * Connects the signal to an instance of {Callback} using the `object`
		 * instance and the `member` method.
		 * 
		 * Returns `true` if the callback was correctly connected to the signal;
		 * otherwise returs `false`.
		 */
		def connect(self, object, member) {
			return self.connect(Callback(object, member))
		}

		/**
		 * Disconnects the signal and the given `func` function. The function
		 * will no more be called by the signal.
		 * 
		 * Returns `true` if the function was correctly disconnected from the
		 * signal; otherwise returs `false`.
		 */
		def disconnect(self, object) {
			found = false
			for i in 0...self.slots.size() {
				slot = self.slots[i]
				if typeof slot == 'Callback' {
					if object is slot.getObject() {
						self.slots.remove(i)
						found = true
					}
				} elif object is slot {
					self.slots.remove(i)
					found = true
				}
			}
			return found
		}

		/**
		 * Disconnects the signal and the callback using the `object` instance
		 * and the `member` method. The callback will no more be called by the
		 * signal.
		 * 
		 * Returns `true` if the callback was correctly disconnected from the
		 * signal; otherwise returs `false`.
		 */
		def disconnect(self, object, member) {
			found = false
			for i in 0...self.slots.size() {
				slot = self.slots[i]
				if typeof slot == 'Callback' {
					if object is slot.getObject() and member is slot.getFunction() {
						self.slots.remove(i)
						found = true
					}
				}
			}
			return found
		}

		/**
		 * Calls each callbacks connected to the signal. Parameters provided to
		 * this operator are also provided to the callbacks.
		 */
		def ()(self, ...) {
			for slot in self.slots {
				slot(*va_args)
			}
		}

		- slots = []
	}
}
