/**
 * This module provides a set of functions to perform operations on a range of
 * elements. The range of elements must implement the `in` operator.
 */

load mint.type
load mint.operator

/**
 * Returns `true` if `predicate` returns `true` for all elements in `range`;
 * otherwie returns `false`.
 */
def all_of(range, predicate) {
    return find_if_not(range, predicate).isEmpty()
}

/**
 * Returns `true` if `predicate` returns `true` for at least one element in
 * `range`; otherwie returns `false`.
 */
def any_of(range, predicate) {
    return not find_if(range, predicate).isEmpty()
}

/**
 * Returns `true` if `predicate` returns `true` for no elements in `range`;
 * otherwie returns `false`.
 */
def none_of(range, predicate) {
    return find_if(range, predicate).isEmpty()
}

/**
 * Calls `func` for each element in `range`.
 */
def each(range, func) {
    for element in range {
        func(element)
    }
}

/**
 * Calls `func` for the `n` first elements in `range`.
 */
def each_n(range, n, func) {
    for element in range {
        if (n--) == 0 {
            break
        }
        func(element)
    }
}

/**
 * Returns the number of elements in `range`.
 */
def count(range) {
    res = 0
    for element in range {
        ++res
    }
    return res
}

/**
 * Returns the number of elements in `range` that is equal to `value`. Both
 * `range` elemnts and `value` must implement the `==` operator.
 */
def count(range, value) {
    res = 0
    for element in range {
        if element == value {
            ++res
        }
    }
    return res
}

/**
 * Returns the number of elements in `range` for which `predicate` returns
 * `true`.
 */
def count_if(range, predicate) {
    res = 0
    for element in range {
        if predicate(element) {
            ++res
        }
    }
    return res
}

/**
 * Returns an iterator containing two iterators on the first non-equal elements
 * of `range` and `other`. The elements in the two ranges must implement the `==`
 * operator.
 */
def mismatch(range, other) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    while not it_range.isEmpty() and not it_other.isEmpty() and it_range.value() == it_other.value() {
        it_range.next()
        it_other.next()
    }

    return (it_range, it_other)
}

/**
 * Returns an iterator containing two iterators on the first elements of `range`
 * and `other` where `predicate` returns `false`.
 */
def mismatch(range, other, predicate) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    while not it_range.isEmpty() and not it_other.isEmpty() and predicate(it_range.value(), it_other.value()) {
        it_range.next()
        it_other.next()
    }

    return (it_range, it_other)
}

/**
 * Returns an iterator on the first element of `range` that match `value`. The
 * elements of `range` must implement the `==` operator.
 */
def find(range, value) {

    it = in_operator(range)

    while not it.isEmpty() {
        if value == it.value() {
            return it
        }
        it.next()
    }

    return it
}

/**
 * Returns an iterator on the first element of `range` where `predicate` returns
 * `true`.
 */
def find_if(range, predicate) {

    it = in_operator(range)

    while not it.isEmpty() {
        if predicate(it.value()) {
            return it
        }
        it.next()
    }

    return it
}

/**
 * Returns an iterator on the first element of `range` where `predicate` returns
 * `false`.
 */
def find_if_not(range, predicate) {

    it = in_operator(range)

    while not it.isEmpty() {
        if not predicate(it.value()) {
            return it
        }
        it.next()
    }

    return it
}

/**
 * Returns an iterator on the beginning of the last occurence of `other` in
 * `range`. The elements of `range` and `other` must implement the `==`
 * operator.
 */
def find_end(range, other) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    if it_other.isEmpty() {
        return ()
    }

    result = ()

    while found = search(range, other) {
        result = copy(found)
        range = found
        range.next()
    }

    return result
}

/**
 * Returns an iterator on the beginning of the last occurence of `other` in
 * `range`. The elements of `range` and `other` are compared using `predicate`.
 */
def find_end(range, other, predicate) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    if it_other.isEmpty() {
        return ()
    }

    result = ()

    while found = search(range, other, predicate) {
        result = copy(found)
        range = found
        range.next()
    }

    return result
}

/**
 * Returns an iterator on the first element of `range` that is equal to an element
 * of `values`. The elements of `range` and `values` must implement the `==`
 * operator.
 */
def find_first_of(range, values) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        for element in values {
            if element == it_range.value() {
                return it_range
            }
        }
        it_range.next()
    }

    return it_range
}

/**
 * Returns an iterator on the first element of `range` where `predicate` returns
 * `true` for an element of `values`.
 */
def find_first_of(range, values, predicate) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        for element in values {
            if predicate(it_range.value(), element) {
                return it_range
            }
        }
        it_range.next()
    }

    return it_range
}

/**
 * Returns an iterator on the first element of `range` that is equal to its next
 * element. The elements of `range` must implement the `==` operator.
 */
def adjacent_find(range) {

    it_range = in_operator(range)
    it_next = in_operator(range)
    it_next.next()

    while not it_next.isEmpty() {
        if it_range.value() == it_next.value() {
            return it_range
        }
        it_range.next()
        it_next.next()
    }

    return ()
}

/**
 * Returns an iterator on the first element of `range` where `predicate` returns
 * `true` when called with the element and its next element.
 */
def adjacent_find(range, predicate) {

    it_range = in_operator(range)
    it_next = in_operator(range)
    it_next.next()

    while not it_next.isEmpty() {
        if predicate(it_range.value(), it_next.value()) {
            return it_range
        }
        it_range.next()
        it_next.next()
    }

    return ()
}

/**
 * Returns an iterator on the beginning of the first occurence of `other` in
 * `range`. The elements of `range` and `other` must implement the `==`
 * operator.
 */
def search(range, other) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        it_search = copy(it_range)
        it_other = in_operator(copy(other))
        while not it_search.isEmpty() and not it_other.isEmpty() {
            if not (it_search.next() == it_other.next()) {
                break
            }
            if it_other.isEmpty() {
                return it_range
            }
        }
        it_range.next()
    }

    return it_range
}

/**
 * Returns an iterator on the beginning of the first occurence of `other` in
 * `range`. The elements of `range` and `other` are compared using `predicate`.
 */
def search(range, other, predicate) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        it_search = copy(it_range)
        it_other = in_operator(copy(other))
        while not it_search.isEmpty() and not it_other.isEmpty() {
            if not predicate(it_search.next(), it_other.next()) {
                break
            }
            if it_other.isEmpty() {
                return it_range
            }
        }
        it_range.next()
    }

    return it_range
}

/**
 * Returns an iterator on the beginning of the first occurence of `n` consecutive
 * elements equals to `value` in `range`. The elements of `range` and `value`
 * must implement the `==` operator.
 */
def search_n(range, n, value) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        result = copy(it_range)
        count = 0
        while count < n {
            if it_range.isEmpty() {
                return ()
            }
            if not (value == it_range.next()) {
                break
            }
            ++count
        }
        if count == n {
            return result
        }
    }

    return ()
}

/**
 * Returns an iterator on the beginning of the first occurence of `n` consecutive
 * elements equals to `value` in `range`. The elements of `range` and `value`
 * are compared using `predicate`.
 */
def search_n(range, n, value, predicate) {

    it_range = in_operator(range)

    while not it_range.isEmpty() {
        result = copy(it_range)
        count = 0
        while count < n {
            if it_range.isEmpty() {
                return ()
            }
            if not predicate(it_range.next(), value) {
                break
            }
            ++count
        }
        if count == n {
            return result
        }
    }

    return ()
}

/**
 * Returns `true` if the last elements of `range` are equal to the elements of
 * `other`; otherwise returns `false`. The elements of `range` and `other` must
 * implement the `==` operator.
 */
def ends_with(range, other) {
    return count(find_end(range, copy(other))) == count(other)
}

/**
 * Returns `true` if the last elements of `range` are equal to the elements of
 * `other`; otherwise returns `false`. The elements of `range` and `other` are
 * compared using `predicate`.
 */
def ends_with(range, other, predicate) {
    return count(find_end(range, copy(other), predicate)) == count(other)
}

/**
 * Returns `true` if the first elements of `range` are equal to the elements of
 * `other`; otherwise returns `false`. The elements of `range` and `other` must
 * implement the `==` operator.
 */
def starts_with(range, other) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    while not it_other.isEmpty() {
        if it_range.isEmpty() {
            return false
        }
        if not (it_range.next() == it_other.next()) {
            return false
        }
    }

    return true
}

/**
 * Returns `true` if the first elements of `range` are equal to the elements of
 * `other`; otherwise returns `false`. The elements of `range` and `other` are
 * compared using `predicate`.
 */
def starts_with(range, other, predicate) {

    it_range = in_operator(range)
    it_other = in_operator(other)

    while not it_other.isEmpty() {
        if it_range.isEmpty() {
            return false
        }
        if not predicate(it_range.next(), it_other.next()) {
            return false
        }
    }

    return true
}

/**
 * Copy all elements in `other` to the corresponding element of `range`. Returns
 * an iterator on the next element of `range`.
 */
def copy(range, other) {

    it_range = in_operator(range)

    for element in other {
        it_range.next() := element
    }

    return it_range
}

/**
 * Copy all elements in `other` for which predicate returns `true` to the
 * corresponding element of `range`. Returns an iterator on the next element of
 * `range`.
 */
def copy_if(range, other, predicate) {

    it_range = in_operator(range)

    for element in other {
        if predicate(element) {
            it_range.next() := element
        }
    }

    return it_range
}

/**
 * Copy the `n` first elements in `other` to the corresponding element of `range`.
 * Returns an iterator on the next element of `range`.
 */
def copy_n(range, n, other) {

    it_range = in_operator(range)
    count = 0

    for element in other {
        if count < n {
            it_range.next() := element
            ++count
        } else {
            return it_range
        }
    }

    return it_range
}

/**
 * Copy all elements in `other` to the corresponding element of `range` starting
 * from the end. Returns a reversed iterator on the next element of `range`.
 */
def copy_backward(range, other) {

    it_range = reversed(range)

    for element in revesed(other) {
        it_range.next() := element
    }

    return it_range
}

// ...

/**
 * Returns an iterator on the elements of `range` in reversed order.
 */
def reversed(range) {

    elements = []

    for element in range {
        elements << element
    }

    for i in elements.size()...0 {
        yield elements[i - 1]
    }
}

/**
 * Reverses the order of the elements in `range` and returns `range`.
 */
def reverse(range) {
    return range := reversed(copy(range))
}


