/**
 * This module provides a set of functions to perform extra operations on strings.
 */

load mint.type
load mint.lang

/**
 * Returns a new string after removing any leading and trailing whitespaces.
 */
$ def trim(self) {
	if isDefined(from = self.indexOf(/\S/)) {
		var to = self.lastIndexOf(/\S/)
		if from == to {
			return self[from]
		}
		return self[from..to]
	}
	return ''
}

/**
 * Returns a new string after removing any leading whitespaces.
 */
$ def ltrim(self) {
	if isDefined(from = self.indexOf(/\S/)) {
		return self[from...self.size()]
	}
	return ''
}

/**
 * Returns a new string after removing any trailing whitespaces.
 */
$ def rtrim(self) {
	if isDefined(to = self.lastIndexOf(/\S/)) {
		if to == 0 {
			return self[to]
		}
		return self[0..to]
	}
	return ''
}

/**
 * Returns `true` if any character in `self` is ASCII; otherwise returns `false`.
 */
$ def isAscii(const self) {
	for c in self {
		if c !~ /[\x00-\x7F]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a decimal digit or a letter; otherwise
 * returns `false`.
 */
$ def isAlnum(const self) {
	for c in self {
		if c !~ /[.alnum.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a letter; otherwise returns `false`.
 */
$ def isAlpha(const self) {
	for c in self {
		if c !~ /[.alpha.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a decimal digit; otherwise returns
 * `false`.
 */
$ def isDigit(const self) {
	for c in self {
		if c !~ /[.digit.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a decimal digit, a letter, or an
 * underscore (`'_'`); otherwise returns `false`.
 */
$ def isWord(const self) {
	for c in self {
		if c !~ /\w/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a blank character; otherwise
 * returns `false`.
 */
$ def isBlank(const self) {
	for c in self {
		if c !~ /[.blank.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a space character; otherwise
 * returns `false`.
 */
$ def isSpace(const self) {
	for c in self {
		if c !~ /[.space.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` a control character; otherwise
 * returns `false`.
 */
$ def isCntrl(const self) {
	for c in self {
		if c !~ /[.cntrl.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` has a graphical representation; 
 * otherwise returns `false`.
 */
$ def isGraph(const self) {
	for c in self {
		if c !~ /[.graph.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` is printable; otherwise returns
 * `false`.
 */
$ def isPrint(const self) {
	for c in self {
		if c !~ /[.print.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` is a punctuation character; otherwise
 * returns `false`.
 */
$ def isPunct(const self) {
	for c in self {
		if c !~ /[.punct.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns `true` if any character in `self` is lowercase; otherwise
 * returns `false`.
 */
$ def isLower(const self) {
	for c in self {
		if c !~ /[.lower.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns a new string after replacing each character by lowercase.
 */
$ def toLower(const self) {
	
}

/**
 * Returns `true` if any character in `self` is uppercase; otherwise
 * returns `false`.
 */
$ def isUpper(const self) {
	for c in self {
		if c !~ /[.upper.]/ {
			return false
		}
	}
	return true
}

/**
 * Returns a new string after replacing each character by uppercase.
 */
$ def toUpper(const self) {
	
}

/**
 * Returns `true` if `self` is capitalized (the first character of each word is
 * uppercase and remaining characters are lowercase); otherwise returns `false`.
 */
$ def isCapitalized(const self) {
	
}

/**
 * Returns a new string after replacing each first character of each word by
 * uppercase and remaining characters by lowercase.
 */
$ def toCapitalized(const self) {
	
}
