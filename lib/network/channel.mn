load network.serializers.text
load network.scheduler
load mint.lockguard
load mint.function
load system.mutex

package Network {

	/*!
	* @class Network.Channel
	*/
	class Channel {
		def new(self, endpoint, _Serializer = TextSerializer) {
			if self.endpoint = endpoint {
				self.endpoint.onStatusChanged = Callback(self, self.notifyStatusChanged)
				self.request = Network.Channel.DataQueue(_Serializer)
				self.reply = Network.Channel.DataQueue(_Serializer)
				return self
			}
		}

		def connect(self) {
			return self.endpoint.connect()
		}

		def listen(self) {
			return self.endpoint.listen()
		}

		def watch(self) {
			return Network.Scheduler.instance().watch(self)
		}

		def unwatch(self) {
			return Network.Scheduler.instance().remove(self)
		}

		def write(self, data) {
			return self.request.push(data)
		}

		def read(self) {
			return self.reply.pop()
		}

		def getSocket(const self) {
			return self.endpoint.getSocket()
		}

		def getEndpoint(const self) {
			return self.endpoint
		}

		def close(self) {
			return self.endpoint.close()
		}

		def getStatus(const self) {
			return self.endpoint.getStatus()
		}

		def getEvents(const self) {
			switch self.endpoint.getStatus() {
			case EndPoint.Status.unknown:
			case EndPoint.Status.disconnected:
			case EndPoint.Status.closed:
			case EndPoint.Status.error:
				return 0

			case EndPoint.Status.connecting:
				return Scheduler.PollEvent.write

			case EndPoint.Status.listening:
				return Scheduler.PollEvent.accept

			case EndPoint.Status.connected:
				return Scheduler.PollEvent.read | Scheduler.PollEvent.write | Scheduler.PollEvent.close | Scheduler.PollEvent.error
			}
		}

		def isNonBlocking(const self) {
			return self.endpoint.isNonBlocking()
		}

		def setNonBlocking(self, enabled) {
			return self.endpoint.setNonBlocking(enabled)
		}

		def notifyStatusChanged(self, %status) {
			if defined self.onStatusChanged {
				self.onStatusChanged(self, status)
			}
		}

		def notifyReadable(self) {
			if buffer = self.endpoint.read() {
				if self.reply.write(buffer) {
					if defined self.onDataReceived {
						self.onDataReceived(self)
					}
				}
			}
		}

		def notifyWritable(self) {
			if self.endpoint.getStatus() is EndPoint.Status.connecting {
				self.endpoint.finalizeConnexion()
			} elif buffer = self.request.read() {
				success, count = self.endpoint.write(buffer)
				if success {
					self.request.remove(count)
				}
			}
		}

		def notifyConnexion(self) {
			self.reply.push(self.endpoint.accept())
			if defined self.onDataReceived {
				self.onDataReceived(self)
			}
		}

		def notifyClosed(self) {
			self.endpoint.close()
			if defined self.onClose {
				self.onClose(self)
			}
		}

		def notifyError(self) {
			self.endpoint.setStatus(EndPoint.Status.error)
			if defined self.onError {
				self.onError(self)
			}
		}

		+ onStatusChanged = none
		+ onDataReceived = none
		+ onError = none
		+ onClose = none

		- class DataQueue {
			def new(self, _Serializer) {
				self.serializer = _Serializer()
				self.mutex = System.Mutex()
				return self
			}

			def write(self, data) {
				lock = LockGuard(self.mutex)
				self.serializer.write(data)
				return self.serializer.containsMessage()
			}

			def read(self) {
				lock = LockGuard(self.mutex)
				return self.serializer.read()
			}

			def remove(self, count) {
				lock = LockGuard(self.mutex)
				self.serializer.remove(count)
			}

			def isEmpty(const self) {
				lock = LockGuard(self.mutex)
				return not self.serializer.containsMessage()
			}

			def push(self, data) {
				lock = LockGuard(self.mutex)
				self.serializer.appendMessage(data)
			}

			def pop(self) {
				lock = LockGuard(self.mutex)
				return self.serializer.nextMessage()
			}

			- serializer = null
			- mutex = null
		}

		- endpoint = null
		- request = null
		- reply = null
	}

}
