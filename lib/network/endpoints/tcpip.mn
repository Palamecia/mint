load mint.lang
load network.endpoint
load exception.system
load serializer.datastream

package Network {
	class TcpIp : EndPoint {
		def new(self, address, port) {
			self = EndPoint.new(self)
			self.address = address
			self.port = port
			return self
		}

		def connect(self) {
			if isDefined(socket = TcpIp.g_lib.call('mint_tcp_ip_socket_open')) {

				self.setSocket(socket)
				self.setStatus(EndPoint.Status.connecting)

				if TcpIp.g_lib.call('mint_tcp_ip_socket_connect', self.socket, self.address, self.port) {
					self.setStatus(EndPoint.Status.connected)
					return true
				}
			}

			return false
		}

		def listen(self, backlog = 1024) {
			if isDefined(socket = TcpIp.g_lib.call('mint_tcp_ip_socket_open')) {

				self.setSocket(socket)

				if TcpIp.g_lib.call('mint_tcp_ip_socket_bind', self.socket, self.address, self.port) {
					if TcpIp.g_lib.call('mint_tcp_ip_socket_listen', self.socket, backlog) {
						self.setStatus(EndPoint.Status.listening)
						return true
					}
				}
			}

			return false
		}

		def accept(self) {

			socket, address, port = TcpIp.g_lib.call('mint_tcp_ip_socket_accept', self.socket)

			if defined socket {
				client = TcpIp(address, port)
				client.setSocket(socket)
				client.setStatus(EndPoint.Status.connected)
				return client
			}
		}

		def write(self, data) {

			if typeof data != typeof DataStream {
				stream = DataStream()
				stream << data
			} else {
				stream = data
			}

			status, value = TcpIp.g_lib.call('mint_tcp_ip_socket_send', self.socket, stream.to_std_vector_uint8_t())

			switch status {
			case EndPoint.IOStatus.io_success:
				return (true, value)

			case EndPoint.IOStatus.io_would_block:
				return false

			case EndPoint.IOStatus.io_closed:
				self.setStatus(EndPoint.Status.closed)
				return false

			case EndPoint.IOStatus.io_error:
				self.setStatus(EndPoint.Status.error)
				raise SystemError(value, self)
			}
		}

		def read(self) {

			stream = DataStream()
			status, errno = TcpIp.g_lib.call('mint_tcp_ip_socket_recv', self.socket, stream.to_std_vector_uint8_t())

			switch status {
			case EndPoint.IOStatus.io_success:
				return stream

			case EndPoint.IOStatus.io_would_block:
				return none

			case EndPoint.IOStatus.io_closed:
				self.setStatus(EndPoint.Status.closed)
				return none

			case EndPoint.IOStatus.io_error:
				self.setStatus(EndPoint.Status.error)
				raise SystemError(errno, self)
			}
		}

		def close(self) {
			if self.socket {
				TcpIp.g_lib.call('mint_tcp_ip_socket_close', self.socket)
				self.setStatus(EndPoint.Status.closed)
				self.socket = none
			}
		}

		def getSocket(const self) {
			return self.socket
		}

		def getAddress(const self) {
			return self.address
		}

		def getPort(const self) {
			return self.port
		}

		def isNonBlocking(const self) {
			return TcpIp.g_lib.call('mint_tcp_ip_socket_is_non_blocking', self.socket)
		}

		def setNonBlocking(self, enabled) {
			return TcpIp.g_lib.call('mint_tcp_ip_socket_set_non_blocking', self.socket, enabled)
		}

		def finalizeConnexion(self) {
			if TcpIp.g_lib.call('mint_tcp_ip_socket_finalize_connexion', self.socket) {
				self.setStatus(EndPoint.Status.connected)
			}
		}

		- def setSocket(self, socket) {
			self.close()
			self.socket = socket
		}

		- @g_lib = lib('libmint-network')
		- socket = none
		- address = ''
		- port = 0
	}
}
