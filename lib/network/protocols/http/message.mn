/**
 * @license
 * Copyright (c) 2024 Gauvain CHERY.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * @module
 */

load serializer.stringstream
load serializer.datastream
load codec.mimetypes
load mint.string
load mint.regex
load mint.hash

package Network {
	package Http {		
		@const Status = {
		    100: "Continue",
		    101: "Switching Protocols",
		    103: "Early Hints",
		    200: "OK",
		    201: "Created",
		    202: "Accepted",
		    203: "Non-Authoritative Information",
		    204: "No Content",
		    205: "Reset Content",
		    206: "Partial Content",
		    300: "Multiple Choices",
		    301: "Moved Permanently",
		    302: "Found",
		    303: "See Other",
		    304: "Not Modified",
		    307: "Temporary Redirect",
		    308: "Permanent Redirect",
		    400: "Bad Request",
		    401: "Unauthorized",
		    402: "Payment Required",
		    403: "Forbidden",
		    404: "Not Found",
		    405: "Method Not Allowed",
		    406: "Not Acceptable",
		    407: "Proxy Authentication Required",
		    408: "Request Timeout",
		    409: "Conflict",
		    410: "Gone",
		    411: "Length Required",
		    412: "Precondition Failed",
		    413: "Payload Too Large",
		    414: "URI Too Long",
		    415: "Unsupported Media Type",
		    416: "Range Not Satisfiable",
		    417: "Expectation Failed",
		    418: "I'm a teapot",
		    422: "Unprocessable Entity",
		    425: "Too Early",
		    426: "Upgrade Required",
		    428: "Precondition Required",
		    429: "Too Many Requests",
		    431: "Request Header Fields Too Large",
		    451: "Unavailable For Legal Reasons",
		    500: "Internal Server Error",
		    501: "Not Implemented",
		    502: "Bad Gateway",
		    503: "Service Unavailable",
		    504: "Gateway Timeout",
		    505: "HTTP Version Not Supported",
		    506: "Variant Also Negotiates",
		    507: "Insufficient Storage",
		    508: "Loop Detected",
		    510: "Not Extended",
		    511: "Network Authentication Required"
		}

		class Message {
			def new(self) {
				return self
			}

			def new(self, identifier, complement = none) {
				switch typeof identifier{
				case 'number':
					self.setStatus(identifier, complement)
					return self
				case 'string':
					self.setMethode(identifier, complement)
					return self
				case 'Network.Http.Message':
					return identifier
				}
			}

			def getStatusCode(const self) {
				return self.code
			}

			def getStatusText(const self) {
				return self.message				
			}

			def setStatus(self, code, message = none) {
				if not defined message and code in Network.Http.Status {
					message = Network.Http.Status[code]
				}
				self.message = message
				self.code = code
			}

			def getTarget(const self) {
				return self.target
			}

			def getMethode(const self) {
				return self.methode
			}

			def setMethode(self, methode, target) {
				self.methode = methode
				self.target = target
			}

			def getAttribute(const self, name) {
				return self.headers.get(name)
			}

			def setAttribute(self, name, value) {
				self.headers[name] = value
			}

			def getBody(const self) {
				return self.body
			}

			def setBody(self, body, contentType = none) {
				var buffer = Serializer.DataStream(body)
				if typeof body == 'string' {
					self.headers['Content-Length'] = body.utf8ByteCount()
				} else {
					self.headers['Content-Length'] = buffer.size()
				}
				if defined contentType {
					self.headers['Content-Type'] = contentType
				} else {
					self.headers['Content-Type'] = Codec.MimeTypes.fromData(body)
				}
				self.body = buffer.getString(0)
			}

			/**
			 * Returns the content of the message as a string.
			 */
			const def toString(const self) {
				return self.body
			}

			const def encode(self) {

				if not defined self.methode {
					if not defined self.code {
						self.code = 200
					}
					if not defined self.message and self.code in Network.Http.Status {
						self.message = Network.Http.Status[self.code]
					}
				}

				var buffer = ''

				if self.methode { // Request mode
					buffer << '%s %s %s\r\n' % (self.methode, self.target, self.version)
				} else { // Response mode
					buffer << '%s %d %s\r\n' % (self.version, self.code, self.message)
				}

				for key, value in self.headers {
					buffer << '%s: %s\r\n' % (key, value)
				}

				buffer << '\r\n' << self.body
				return Serializer.DataStream.fromUtf8Bytes(buffer, buffer.utf8ByteCount())
			}

			@const def decode(stream, length) {
				if length {

					var self = Network.Http.Message()
					var buffer = Serializer.StringStream(stream.getString(0, length))
					var token = buffer.readWord()

					if token.startsWith('HTTP/') {
						self.version = token
						self.code = number(buffer.readWord())
						self.message = buffer.readLine().trim()
					} else {
						self.methode = token
						self.target = buffer.readWord()
						self.version = buffer.readLine().trim()
					}

					while header = RegexMatch(/(.+):\s*(.+)?\r?/.match(buffer.readLine())) {
						self.headers[header.capturedText(1).trim()] = header.capturedText(2).trim()
					}

					self.body = buffer.read()
					return self
				}
			}

			- final version = 'HTTP/1.0'
			- final headers = {}
			- final body = none
			// Request only
			- final methode = none
			- final target = none
			// Response only
			- final message = none
			- final code = none
		}
	}
}
