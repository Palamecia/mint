load system.mutex
load system.thread
load mint.lockguard

package Network {

	class Scheduler {
		enum PollEvent {
			read   = 0x0001
			write  = 0x0002
			accept = 0x0004
			error  = 0x0008
			close  = 0x0010
		}

		class PollDescriptor {
			def new(self, channel) {
				self.handle = self.g_lib.call('mint_scheduler_pollfd_new', channel.getSocket())
				self.handle.delete = def [g_lib = Network.Scheduler.PollDescriptor.g_lib] (self) {
					g_lib.call('mint_scheduler_pollfd_delete', self)
				}
				return self
			}

			def getHandle(const self) {
				return self.handle
			}

			def getEvents(const self) {
				return self.g_lib.call('mint_scheduler_get_revents', self.handle)
			}

			def setEvents(self, events) {
				return self.g_lib.call('mint_scheduler_set_events', self.handle, events)
			}

			def poll(self, timeout = 500) {
				return Scheduler.poll([self], timeout)
			}

			- @g_lib = lib('libmint-network')
			- handle
		}

		~def new(self) {
			self.thread = System.Thread(self, self.synchronizationLoop)
			self.mutex = System.Mutex()
			return self
		}

		@def instance() {
			return Scheduler.g_instance
		}

		@def poll(fdset, timeout) {

			var handle_set = []

			for fd in fdset {
				handle_set << fd.getHandle()
			}

			return Scheduler.g_lib.call('mint_scheduler_poll', handle_set, timeout)
		}

		def startSynchronizationLoop(self) {
			self.loop_running = true
			self.thread.start()
		}

		def stopSynchronizationLoop(self) {
			self.loop_running = false
			self.thread.join()
		}

		def watch(self, channel) {
			var lock = LockGuard(self.mutex)
			if channel in self.channels {
				return false
			}
			self.channels[channel] = Network.Scheduler.PollDescriptor(channel)
			channel.setNonBlocking(true)
			return true
		}

		def remove(self, channel) {
			var lock = LockGuard(self.mutex)
			if channel in self.channels {
				self.channels.remove(channel)
				return true
			}
			return false
		}

		#def synchronizationLoop(self) {
			while self.loop_running {
				self.synchronize()
			}
		}

		def synchronize(self, timeout = 500) {

			var channelset = []
			var fdset = []

			for channel, fd in self.channels {
				fd.setEvents(channel.getEvents())
				channelset << channel
				fdset << fd
			}

			if Network.Scheduler.poll(fdset, timeout) {

				for i in 0...fdset.size() {
					revents = fdset[i].getEvents()
					channel = channelset[i]
					if revents & Scheduler.PollEvent.read and defined channel.notifyReadable {
						channel.notifyReadable()
					}
					if revents & Scheduler.PollEvent.write and defined channel.notifyWritable {
						channel.notifyWritable()
					}
					if revents & Scheduler.PollEvent.accept and defined channel.notifyConnexion {
						channel.notifyConnexion()
					}
					if revents & Scheduler.PollEvent.error and defined channel.notifyError {
						channel.notifyError()
					}
					if revents & Scheduler.PollEvent.close and defined channel.notifyClosed {
						channel.notifyClosed()
					}
				}

				return true
			}

			return false
		}

		- @g_instance
		- @g_lib = lib('libmint-network')
		- loop_running = false
		- thread = null
		- mutex = null
		- channels = {}
	}

	Scheduler.g_instance = Scheduler()

}
