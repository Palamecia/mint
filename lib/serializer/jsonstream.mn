/**
 * This module provides the {DataStream} class which allow to read and write JSON
 * documents.
 */

load mint.lang
load mint.type
load exception.exception
load serializer.documentstream

/**
 * This class class provides a way to read and write JSON documents.
 */
class JsonStream : DocumentStream {
	/**
	 * Returns the content of `str` with special characters escaped to be
	 * inserted in a JSON document.
	 */
	@const def escapeString(str) {
		var escaped_string = ''
		for c in str {
			switch c {
			case '"':
		        escaped_string << '\\"'
		        break
		    case '\\':
		        escaped_string << '\\\\'
		        break
		    case '\b':
		        escaped_string << '\\b'
		        break
		    case '\f':
		        escaped_string << '\\f'
		        break
		    case '\n':
		        escaped_string << '\\n'
		        break
		    case '\r':
		        escaped_string << '\\r'
		        break
		    case '\t':
		        escaped_string << '\\t'
		        break
			default:
				escaped_string << c
			}
		}
		return escaped_string
	}

	/**
	 * Returns `true` if the stream indent the JSON when writing; otherwise
	 * returns `false`.
	 */
	const def isIndented(const self) {
		return self.indented
	}

	/**
	 * Enables the indentation of the JSON writed to the stream. If `indented`
	 * is `true`, the JSON will be indented; otherwise the JSON will be
	 * compact.
	 * 
	 * Indented example:
	 * ```json
	 * {
	 *     "array": [
	 *         {
	 *             "object": {
	 *                 "str": "value",
	 *                 "int": 32,
	 *                 "bool": false,
	 *                 "null": null
	 *             }
	 *         }
	 *     ]
	 * }
	 * ```
	 * 
	 * Compact example:
	 * ```json
	 * {"array": [{"object": {"str": "value","int": 32,"bool": false,"null": null}}]}
	 * ```
	 * 
	 * > By default, the data is indented.
	 */
	const def setIndented(self, indented) {
		self.indented = indented
	}

	/**
	 * Reads the content of the stream and return it as an hash. If the content
	 * of the stream is not a valid JSON, an instance of {DocumentStream.InvalidDocument}
	 * is raised.
	 */
	const def read(self) {
		var parser = JsonStream.Parser(self)
		return parser.parse()
	}

	/**
	 * Writes the content of `data` to the stream. The indentation mode set by
	 * {@see setIndented} is used to adapt the format. The content is converted
	 * to JSON using the {@see valueToJson} function.
	 */
	const def write(self, data) {
		DocumentStream.write(self, self.writeJson(data))
	}

	/**
	 * Reads an object from the stream and stores it in `data`, then returns a
	 * reference to the stream.
	 */
	const def >>(self, data) {
		data := self.read()
		return self
	}

	/**
	 * Writes the content of `data` to the stream using the {@see write}
	 * function, then returns a reference to the stream.
	 */
	const def <<(self, data) {
		self.write(data)
		return self
	}

	/**
	 * Writes the element `value` to the stream with the current indentation.
	 * The element is converted to JSON using {@see valueToJson}.
	 */
	- const def writeJson(self, value) {
		return ('\t' * self.indentationLevel) + self.valueToJson(value)
	}

	/**
	 * Converts the `value` element to JSON as follow :
	 * * hashes are converted to JSON objects.
	 * * arrays are converted to JSON arrays.
	 * * numbers are converted to JSON numeric values.
	 * * strings are converted to JSON string values using {@see escapeString}.
	 * * booleans are converted to JSON boolean values.
	 * * `null` is converted to JSON null value.
	 * * for other types, the conversion methods are tested in the following
	 *   order : `toBoolean`, `toNumber`, `	toString`. If no conversion method
	 *   is found, the data is cast to string.
	 */
	- const def valueToJson(self, value) {
		switch typeof value {
		case 'null':
			return 'null'
		case 'number':
		case 'boolean':
			return '%s' % value
		case 'string':
			return '"%s"' % JsonStream.escapeString(value)
		case 'array':
			elements = []
			if self.indented {
				self.indentationLevel++
				for item in value {
					elements << self.writeJson(item)
				}
				self.indentationLevel--
				if elements.isEmpty() {
					return '[]'
				} else {
					return '[\n%s\n%s]' % (elements.join(',\n'), ('\t' * self.indentationLevel))
				}
			} else {
				for item in value {
					elements << self.writeJson(item)
				}
				return '[%s]' % elements.join(',')
			}
		case 'hash':
			elements = []
			if self.indented {
				self.indentationLevel++
				for key, item in value {
					elements << '%s: %s' % (self.writeJson(key), self.valueToJson(item))
				}
				self.indentationLevel--
				if elements.isEmpty() {
					return '{}'
				} else {
					return '{\n%s\n%s}' % (elements.join(',\n'), ('\t' * self.indentationLevel))
				}
			} else {
				for key, item in value {
					elements << '%s: %s' % (self.valueToJson(key), self.valueToJson(item))
				}
				return '{%s}' % elements.join(',')
			}
		default:
			for member in ('toBoolean', 'toNumber', 'toString') {
				if defined value.$(member) {
					return self.valueToJson(value.$(member)())
				}
			}
			return '"%s"' % JsonStream.escapeString(string(value))
		}
	}

	/**
	 * This class provides a parser to convert a JSON stream to built-in types.
	 * 
	 * The elements are converted as follow :
	 * * JSON objects are converted to hashes
	 * * JSON arrays are converted to arrays
	 * * JSON boolean values are converted to booleans
	 * * JSON numeric values are converted to numbers
	 * * JSON string values are converted to strings
	 * * JSON null value is converted to `null`
	 */
	- class Parser {
		/**
		 * Creates a new parser on the stream given by `stream`.
		 */
		const def new(self, stream) {
			self.stream = stream
			return self
		}

		/**
		 * Returns an instance of hash or array corresponding to the next JSON
		 * element in the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		const def parse(self) {
			switch token = self.nextToken() {
			case '{':
				return self.parseNextObject()
			case '[':
				return self.parseNextArray()
			default:
				raise DocumentStream.InvalidDocument(self.stream, "illegal value")
			}
		}

		/**
		 * Returns the value converted from the next element of the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		- const def parseNextElement(self) {
			switch token = self.nextToken() {
			case '{':
				return self.parseNextObject()
			case '[':
				return self.parseNextArray()
			case '"':
				return self.parseNextString()
			case is none:
				raise DocumentStream.InvalidDocument(self.stream, "unterminated element")
			default:
				if isDefined(value = self.parseNextValue(token)) {
					return value
				} else {
					raise DocumentStream.InvalidDocument(self.stream, "unexpected token '%s'" % token)
				}
			}
		}

		/**
		 * Returns the value converted from the next object of the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		- const def parseNextObject(self) {
			token = self.nextToken()
			json_object = {}
			while token == '"' {
				member = self.parseNextString()
				token = self.nextToken()
				if token == ':' {
					value = self.parseNextElement()
				} else {
					raise DocumentStream.InvalidDocument(self.stream, "missing name separator")
				}
				token = self.nextToken()
				switch token {
				case ',':
					token = self.nextToken()
				case '}':
					json_object[member] = value
					break
				default:
					raise DocumentStream.InvalidDocument(self.stream, "missing value separator")
				}
			}
			if token != '}' {
				raise DocumentStream.InvalidDocument(self.stream, "unterminated object")
			}
			return json_object
		}

		/**
		 * Returns the value converted from the next array of the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		- const def parseNextArray(self) {
			token = self.nextToken()
			json_array = []
			if token != ']' {
				self.discardToken()
				json_array << self.parseNextElement()
				token = self.nextToken()
				while token == ',' {
					json_array << self.parseNextElement()
					token = self.nextToken()
				}
				if token != ']' {
					raise DocumentStream.InvalidDocument(self.stream, "unterminated array")
				}
			}
			return json_array
		}

		/**
		 * Returns the value converted from the next string of the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		- const def parseNextString(self) {
			var json_string = ''
			for (c = self.nextChar(), c = self.nextChar(), defined c and c != '"') {
				switch c {
				case '\\':
					switch c = self.nextChar() {
					case '"':
				        json_string << '"'
				        break
				    case '\\':
				        json_string << '\\'
				        break
				    case 'b':
				        json_string << '\b'
				        break
				    case 'f':
				        json_string << '\f'
				        break
				    case 'n':
				        json_string << '\n'
				        break
				    case 'r':
				        json_string << '\r'
				        break
				    case 't':
				        json_string << '\t'
				        break
				    case 'u':
				        code = '0x'
				        for i in 0...4 {
				        	c = self.nextChar()
				        	if c =~ /[0-9a-fA-F]/ {
				        		code << c
				        	} else {
				        		raise DocumentStream.InvalidDocument(self.stream, "invalid escape sequence")
				        	}
				        }
				        json_string << ('%c' % number(code))
				        break
				    default:
				        json_string << c
					}
					break

				default:
					json_string << c
				}
			}
			if not defined c {
				raise DocumentStream.InvalidDocument(self.stream, "unterminated string")
			}
			return json_string
		}

		/**
		 * Returns the value converted from the next value of the stream.
		 * 
		 * An instance of {DocumentStream.InvalidDocument} is raised on error.
		 */
		- const def parseNextValue(self, token) {
			if token =~ /\d/ or token == '-' or token == '+' {
				for (c = self.nextChar(), c = self.nextChar(), c =~ /\d/) {
					token << c
				}
				self.discardToken()
				return number(token)
			} else {
				for (c = self.nextChar(), c = self.nextChar(), c =~ /[a-z]/) {
					token << c
				}
				self.discardToken()
				switch token {
				case 'null':
					return null
				case 'false':
					return false
				case 'true':
					return true
				default:
					break
				}
			}
		}

		/**
		 * Discards the last token that was read. The same token will then be
		 * returned by the next call to {@see nextToken}.
		 */
		- const def discardToken(self) {
			self.discarded = true
		}

		/**
		 * Returns the next token of the stream. A token is a character that does
		 * not match the `/\s/` regex.
		 */
		- const def nextToken(self) {
			if self.discarded {
				self.discarded = false
				c = self.c
			} else {
				c = self.nextChar()
			}
			while defined c and c =~ /\s/ {
				c = self.nextChar()
			}
			return c
		}

		/**
		 * Returns the next character of the stream.
		 */
		- const def nextChar(self) {
			return self.c = self.stream.readChar()
		}

		/// Internal stream object.
		- stream = null

		/// Internal discarded state.
		- discarded = false

		/// Internal last read character.
		- c = none
	}

	/// Internal current indentation level.
	- indentationLevel = 0

	/// Internal indentation format state.
	- indented = true
}
