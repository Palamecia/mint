/**
 * @license
 * Copyright (c) 2024 Gauvain CHERY.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * @module
 * This module provides the {Serializer.XmlDomStream} class which allow to read
 * and write XML documents with a DOM algorithm.
 */

load serializer.xmlstream
load exception.exception
load mint.string
load mint.hash
load mint.type
load mint.lang

package Serializer {

/**
 * This class class provides a way to read and write XML documents using a DOM
 * algorithm.
 */
class XmlDomStream : Serializer.XmlStream {
	/**
	 * Creates a new stream for reading and writing data using `stream`.
	 */
	const def new(self, stream) {
		if self = Serializer.XmlStream.new(self, stream) {
			self.context = Serializer.XmlDomStream.Context(self)
			return self
		}
	}

	/**
	 * Reads the content of the stream and return it as an instance of
	 * {Serializer.XmlDomDocument}. If the content of the stream is not a valid
	 * XML, an instance of {Serializer.DocumentStream.InvalidDocument} is raised.
	 */
	override const def read(self) {
		while let var token = Serializer.XmlStream.read(self) {
			switch token {
			case Serializer.XmlStream.TokenType.Invalid:
				return none
			case Serializer.XmlStream.TokenType.ProcessingInstruction:
				self.context.onProcessingInstruction(self.getProcessingInstructionTarget(), self.getProcessingInstructionData())
				break
			case Serializer.XmlStream.TokenType.StartDocument:
				self.context.onStartDocument()
				break
			case Serializer.XmlStream.TokenType.EndDocument:
				self.context.onEndDocument()
				return self.context.document
			case Serializer.XmlStream.TokenType.StartElement:
				self.context.onStartElement(self.getNamespaceUri(), self.getLocalName(), self.getQualifiedName(), self.getAttributes())
				break
			case Serializer.XmlStream.TokenType.EndElement:
				self.context.onEndElement(self.getNamespaceUri(), self.getLocalName(), self.getQualifiedName())
				break
			case Serializer.XmlStream.TokenType.Characters:
				self.context.onCharacters(self.getText())
				break
			case Serializer.XmlStream.TokenType.Comment:
				self.context.onComment(self.getText())
				break
			case Serializer.XmlStream.TokenType.CDATA:
				self.context.onCData(self.getText())
				break
			case Serializer.XmlStream.TokenType.DTD:
				self.context.onDtd(self.getText())
				break
			}
		}
	}

	/**
	 * Writes the XML described by `data` to the stream. The XML will be adapted
	 * to match the configuration sets by {@see setIndented} and
	 * {@see setAutoClosing}. Returns `true` if all the data have been correctly
	 * writed; otherwise returns `false`.  If the content of the `data` is not a
	 * valid XML, an instance of {Serializer.DocumentStream.InvalidDocument} is
	 * raised.
	 */
	override const def write(self, data) {
		switch typeof data {
		case 'Serializer.XmlDomProcessingInstruction':
			if not self.writeProcessingInstruction(data.qualifiedName, data.attributes) {
				return false
			}
			break
		case 'Serializer.XmlDomDocument':
			if not self.writeStartDocument() {
				return false
			}
			for var child in data {
				if not self.write(child) {
					return false
				}
			}
			if not self.writeEndDocument() {
				return false
			}
			break
		case 'Serializer.XmlDomDocumentFragment':
			for var child in data {
				if not self.write(child) {
					return false
				}
			}
			break
		case 'Serializer.XmlDomElement':
			if not self.writeStartElement(data.getNamespaceUri(), data.getLocalName(), data.getTagName(), reader.getAttributes()) {
				return false
			}
			for var child in data {
				if not self.write(child) {
					return false
				}
			}
			if not self.writeEndElement(data.getNamespaceUri(), data.getLocalName(), data.getTagName()) {
				return false
			}
			break
		case 'Serializer.XmlDomText':
			if not self.writeCharacters(data.getData()) {
				return false
			}
			break
		case 'Serializer.XmlDomComment':
			if not self.writeComment(data.getData()) {
				return false
			}
			break
		case 'Serializer.XmlDomCData':
			if not self.writeCData(data.getData()) {
				return false
			}
			break
		case 'Serializer.XmlDomDtd':
			if not self.writeDtd(data.getData()) {
				return false
			}
			break
		default:
			return Serializer.XmlStream.write(self, data)
		}
		return true
	}

	/**
	 * This class provides the parsing context to convert XML into nodes.
	 */
	- class Context {

		/// Internal stream object.
		- final stream = null

		/// Current document node.
		+ final document = none

		/// Document's type definition.
		+ final documentType = none

		/// Document's root element.
		+ final rootElement = none

		/// Current element.
		+ final currentElement = none

		/// Parent elements stack.
		+ final parentElements = []

		/**
		 * Creates a new parsing context.
		 */
		const def new(self, stream) {
			self.stream = stream
			return self
		}

		/**
		 * Creates a new {Serializer.XmlDomProcessingInstruction} node into the
		 * context. If the node can not correctly be inserted into the context,
		 * an instance of {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onProcessingInstruction(self, name, attributes) {

			if defined self.currentElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "unexpected processing instruction after document element")
			}

			self.document.appendChild(Serializer.XmlDomProcessingInstruction(name, attributes))
		}

		/**
		 * Creates a new {Serializer.XmlDomDocument} node into the context.
		 */
		const def onStartDocument(self) {
			self.document = Serializer.XmlDomDocument()
			self.documentType = none
			self.rootElement = none
			self.currentElement = none
			self.parentElements.clear()
		}

		/**
		 * Finalize the {Serializer.XmlDomDocument} node of the context. If all
		 * the elements were not correctly closed, an instance of
		 * {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onEndDocument(self) {
			if defined self.currentElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "premature end of document")
			}
		}

		/**
		 * Creates a new {Serializer.XmlDomElement} node and push it in the context.
		 */
		const def onStartElement(self, namespaceUri, localName, qualifiedName, attributes) {

			var attrs = Serializer.XmlDomNamedNodeMap()
			for var attr in attributes {
				attrs.setNamedItem(self.document.createAttribute(self, attr))
			}

			var element = self.document.createElementNS(namespaceUri, qualifiedName, attrs)

			if defined self.currentElement {
				self.parentElements << self.currentElement
			} elif defined self.rootElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "unexpected multiple document element")
			} else {
				self.rootElement = element
			}

			self.currentElement = element
		}

		/**
		 * Finalize the last pushed {Serializer.XmlDomElement} of the context.
		 * If the closed element does not match the last pushed element, an
		 * instance of {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onEndElement(self, namespaceUri, localName, qualifiedName) {

			var node = self.currentElement
			if self.parentElements.isEmpty() {
				self.currentElement = none
			} else {
				self.currentElement = self.parentElements[-1]
				self.parentElements.remove(-1)
			}

			if (not defined namespaceUri or namespaceUri.isEmpty()) \
				? (qualifiedName == node.getTagName()) \
				: (namespaceUri == node.getNamespaceUri() and localName == node.getLocalName()) {
				var parent = self.currentParent()
				parent.appendChild(node)
			} else {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "STag/ETag mismatch")
			}
		}

		/**
		 * Creates a new {Serializer.XmlDomCharacterData} node into the context.
		 * If the node was not correctly inserted into the context, an instance
		 * of {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onCharacters(self, content) {
			
			if not self.currentElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "expected document element before characters")
			}

			self.currentElement.appendChild(self.document.createTextNode(content))
		}

		/**
		 * Creates a new {Serializer.XmlDomComment} node into the context.
		 */
		const def onComment(self, content) {
			var parent = self.currentParent()
			parent.appendChild(self.document.createComment(content))
		}

		/**
		 * Creates a new {Serializer.XmlDomCData} node into the context. If the
		 * node was not correctly inserted into the context, an instance of
		 * {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onCData(self, content) {

			if not self.currentElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "expected document element before CDATA section")
			}

			self.currentElement.appendChild(self.document.createCDATASection(content))
		}

		/**
		 * Creates a new {Serializer.XmlDomDtd} node into the context. If the
		 * node was not correctly inserted into the context, an instance of
		 * {Serializer.DocumentStream.InvalidDocument} is raised.
		 */
		const def onDtd(self, content) {
			if self.currentElement {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "unexpected document type after document element")
			} elif self.documentType {
				raise Serializer.DocumentStream.InvalidDocument(self.stream, "unexpected multiple document type")
			} else {
				self.documentType = Serializer.XmlDomDtd(content)
				self.document.appendChild(node)
			}
		}

		/**
		 * Returns the stack's top parent element if any or the document root node.
		 */
		- final const def currentParent(const self) {
			if self.parentElements.isEmpty() {
				return self.document 
			}
			return self.parentElements[-1]
		}
	}

	/// Internal context object.
	- final context = null
}

/**
 * This class provides the context of a DOM exception.
 */
class XmlDomException : Exception.Exception {
	/**
	 * This enum describes the error codes of DOM exceptions.
	 */
	enum Code {
		INDEX_SIZE_ERR = 1
		DOMSTRING_SIZE_ERR = 2
		HIERARCHY_REQUEST_ERR = 3
		WRONG_DOCUMENT_ERR = 4
		INVALID_CHARACTER_ERR = 5
		NO_DATA_ALLOWED_ERR = 6
		NO_MODIFICATION_ALLOWED_ERR = 7
		NOT_FOUND_ERR = 8
		NOT_SUPPORTED_ERR = 9
		INUSE_ATTRIBUTE_ERR = 10
		INVALID_STATE_ERR = 11
		SYNTAX_ERR = 12
		INVALID_MODIFICATION_ERR = 13
		NAMESPACE_ERR = 14
		INVALID_ACCESS_ERR = 15
		VALIDATION_ERR = 16
		TYPE_MISMATCH_ERR = 17
		SECURITY_ERR = 18
		NETWORK_ERR = 19
		ABORT_ERR = 20
		URL_MISMATCH_ERR = 21
		QUOTA_EXCEEDED_ERR = 22
		TIMEOUT_ERR = 23
		INVALID_NODE_TYPE_ERR = 24
		DATA_CLONE_ERR = 25
	}

	/**
	 * This hash provides the names associated to the values of
	 * {Serializer.XmlDomException.Code}.
	 */
	@const Names = none

	/**
	 * This hash provides the messages associated to the values of
	 * {Serializer.XmlDomException.Code}.
	 */
	@const Messages = none

	/**
	 * Creates a new exception context. The message is found in the
	 * {Serializer.XmlDomException.Messages} hash and the name is found in the
	 * {Serializer.XmlDomException.Names} hash using `code`.
	 */
	const def new(self, code) {
		self.code = code
		self.name = Serializer.XmlDomException.Names.get(code, 'Error')
		self.message = Serializer.XmlDomException.Messages.get(code)
		return self
	}

	/**
	 * Creates a new exception context.
	 */
	const def new(self, name, message) {
		self.name = name
		self.message = message
		return self
	}

	/**
	 * Creates a new exception context.
	 */
	const def new(self, code, name, message) {
		self.code = code
		self.name = (name or Serializer.XmlDomException.Names.get(code, 'Error'))
		self.message = (message or Serializer.XmlDomException.Messages.get(code))
		return self
	}

	/**
	 * Returns the name of the exception.
	 */
	const def getName(const self) {
		return self.name
	}

	/**
	 * Returns the message of the exception.
	 */
	const def getMessage(const self) {
		return self.message
	}

	/**
	 * Returns the code of the exception or `none` if there is no code.
	 */
	const def getCode(const self) {
		return self.code
	}

	/**
	 * Returns the exception informations as a string.
	 */
	const def toString(const self) {
		return '%s : %s' % (self.name, self.message)
	}

	/// Internal exception name.
	- final name = ''
	
	/// Internal exception message.
	- final message = ''
	
	/// Internal exception code.
	- final code = none
}

Serializer.XmlDomException.Names = {
	Serializer.XmlDomException.Code.INDEX_SIZE_ERR : 'IndexSizeError',
	Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR : 'HierarchyRequestError',
	Serializer.XmlDomException.Code.WRONG_DOCUMENT_ERR : 'WrongDocumentError',
	Serializer.XmlDomException.Code.INVALID_CHARACTER_ERR : 'InvalidCharacterError',
	Serializer.XmlDomException.Code.NO_MODIFICATION_ALLOWED_ERR : 'NoModificationAllowedError',
	Serializer.XmlDomException.Code.NOT_FOUND_ERR : 'NotFoundError',
	Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR : 'NotSupportedError',
	Serializer.XmlDomException.Code.INUSE_ATTRIBUTE_ERR : 'InUseAttributeError',
	Serializer.XmlDomException.Code.INVALID_STATE_ERR : 'InvalidStateError',
	Serializer.XmlDomException.Code.SYNTAX_ERR : 'SyntaxError',
	Serializer.XmlDomException.Code.INVALID_MODIFICATION_ERR : 'InvalidModificationError',
	Serializer.XmlDomException.Code.NAMESPACE_ERR : 'NamespaceError',
	Serializer.XmlDomException.Code.INVALID_ACCESS_ERR : 'InvalidAccessError',
	Serializer.XmlDomException.Code.TYPE_MISMATCH_ERR : 'TypeMismatchError',
	Serializer.XmlDomException.Code.SECURITY_ERR : 'SecurityError',
	Serializer.XmlDomException.Code.NETWORK_ERR : 'NetworkError',
	Serializer.XmlDomException.Code.ABORT_ERR : 'AbortError',
	Serializer.XmlDomException.Code.URL_MISMATCH_ERR : 'URLMismatchError',
	Serializer.XmlDomException.Code.QUOTA_EXCEEDED_ERR : 'QuotaExceededError',
	Serializer.XmlDomException.Code.TIMEOUT_ERR : 'TimeoutError',
	Serializer.XmlDomException.Code.INVALID_NODE_TYPE_ERR : 'InvalidNodeTypeError',
	Serializer.XmlDomException.Code.DATA_CLONE_ERR : 'DataCloneError'
}

Serializer.XmlDomException.Messages = {
	Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR : 'The operation would yield an incorrect node tree',
	Serializer.XmlDomException.Code.WRONG_DOCUMENT_ERR : 'The object is in the wrong document',
	Serializer.XmlDomException.Code.INVALID_CHARACTER_ERR : 'The string contains invalid characters',
	Serializer.XmlDomException.Code.NO_MODIFICATION_ALLOWED_ERR : 'The object can not be modified',
	Serializer.XmlDomException.Code.NOT_FOUND_ERR : 'The object can not be found here',
	Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR : 'The operation is not supported',
	Serializer.XmlDomException.Code.INUSE_ATTRIBUTE_ERR : 'The attribute is in use by another element',
	Serializer.XmlDomException.Code.INVALID_STATE_ERR : 'The object is in an invalid state',
	Serializer.XmlDomException.Code.SYNTAX_ERR : 'The string did not match the expected pattern',
	Serializer.XmlDomException.Code.INVALID_MODIFICATION_ERR : 'The object can not be modified in this way',
	Serializer.XmlDomException.Code.NAMESPACE_ERR : 'The operation is not allowed by Namespaces in XML',
	Serializer.XmlDomException.Code.SECURITY_ERR : 'The operation is insecure',
	Serializer.XmlDomException.Code.NETWORK_ERR : 'A network error occurred',
	Serializer.XmlDomException.Code.ABORT_ERR : 'The operation was aborted',
	Serializer.XmlDomException.Code.QUOTA_EXCEEDED_ERR : 'The quota has been exceeded',
	Serializer.XmlDomException.Code.TIMEOUT_ERR : 'The operation timed out',
	Serializer.XmlDomException.Code.INVALID_NODE_TYPE_ERR : 'The supplied node is incorrect or has an incorrect ancestor for this operation',
	Serializer.XmlDomException.Code.DATA_CLONE_ERR : 'The object can not be cloned'
}

/**
 * This class represents abstract node in the parsed XML document.
 */
class XmlDomNode {
	/**
	 * Returns `true` if `other` is equal to `self`; otherwise returns `false`.
	 */
	const def ==(const self, const other) {
		if typeof self != typeof other {
			return false
		}
		if self.children.size() != other.children.size() {
			return false
		}
		for var index in 0...self.children.size() {
			if self.children[index] != other.children[index] {
				return false
			}
		}
		return true
	}

	/**
	 * Returns `false` if `other` is equal to `self`; otherwise returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self == other)
	}

	const def contains(const self, const other) {
		if self is other {
			return true
		}
		for var node in self.children {
			if node.contains(other) {
				return true
			}
		}
		return false
	}

	/**
	 * Returns `true` if this node contains `node`; otherwise returns
	 * `false`.
	 */
	const def in(const self, const node) {
		if node in self.children {
			return true
		}
		for var child in self.children {
			if node in child {
				return true
			}
		}
		return false
	}

	/**
	 * Returns an iterator on each direct children nodes of this node.
	 */
	const def in(const self) {
		for var node in self.children {
			yield node
		}
	}

	/**
	 * Returns the document to which this node belongs.
	 */
	const def getOwnerDocument(const self) {
		return self.document
	}

	/**
	 * Returns the root node of this node. If `composed` is `true`, the root node
	 * may be the first instance of {Serializer.XmlDomDocumentFragment} containing
	 * the node; otherwise the root node is the first node whose parent is `null`.
	 */ 
	const def getRootNode(composed = false) {
		if composed and Serializer.XmlDomDocumentFragment.isBaseOrSame(self) {
			return self
		}
		if self.parent {
			return self.parent.getRootNode(composed)
		}
		return self
	}

	/**
	 * Returns the parent node. If this node has no parent, `null` is returned.
	 */
	const def getParentNode(const self) {
		return self.parent
	}

	/**
	 * Returns the parent node if it is an instance of {Serializer.XmlDomElement};
	 * otherwise returns `null`.
	 */
	const def parentElement(const self) {
		return typeof self.parent == 'Serializer.XmlDomElement' ? self.parent : null
	}

	/**
	 * Returns `true` if the node has childrens; otherwise returns `false`.
	 */
	const def hasChildNodes(const self) {
		return not self.children.isEmpty()
	}

	/**
	 * Returns an array containing the children nodes of this node.
	 */
	const def getChildNodes(const self) {
		return self.children
	}

	/**
	 * Returns the first child of this node of this node or `null` id the node
	 * has no children.
	 */
	const def getFirstChild(const self) {
		if not self.children.isEmpty() {
			return self.children[0]
		}
		return null
	}

	/**
	 * Returns the last child of this node of this node or `null` id the node
	 * has no children.
	 */
	const def getLastChild(const self) {
		if not self.children.isEmpty() {
			return self.children[-1]
		}
		return null
	}

	/**
	 * Returns the previous sibling in the document tree or `null`.
	 */
	const def getPreviousSibling(const self) {
		var index = self.parent.children.indexOf(self)
		return index > 0 ? self.parent.children[index - 1] : null
	}

	/**
	 * Returns the next sibling in the document tree or `null`.
	 */
	const def getNextSibling(const self) {
		var index = self.parent.children.indexOf(self)
		return index < self.parent.children.size() - 1 ? self.parent.children[index + 1] : null
	}

	/**
	 * Returns the node's meaningfull value.
	 */
	const def getNodeValue(const self) {
		return null
	}

	/**
	 * Returns the node's text content by concatenating its meaningfull value
	 * with the value of each its descendants recursively.
	 */
	const def getTextContent(const self) {
		return null
	}

	/**
	 * Removes empty exclusive Text nodes and concatenates the data of remaining
	 * contiguous exclusive Text nodes into the first of their nodes.
	 */
	const def normalize(self) {
		for var node in self.children {
			if typeof node == 'Serializer.XmlDomText' {
				let var index = self.children.indexOf(node)
				if not node.length() {
					self.children.remove(index)
					continue
				}
				while index + 1 < self.children.size() {
					let var sibling = self.children[i]
					if typeof sibling != 'Serializer.XmlDomText' {
						break
					}
					node.appendData(sibling.getData())
					self.children.remove(index + 1)
				}
			}
		}
	}

	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	const def cloneNode(self, deep = false) {
		var clone = new(typeof self)
		clone.document = self.document
		return clone
	}

	/**
	 * Returns `true` is `self` and `other` are equals nodes (i.e `self` and
	 * `other` have the same properties); otherwise returns `false`.
	 */
	const def isEqualNode(const self, const other) {
		return self == other
	}

	/**
	 * Returns `true` is `self` and `other` are the same node (i.e `self` is
	 * `other`); otherwise returns `false`.
	 */
	const def isSameNode(const self, const other) {
		return self is other
	}

	/**
	 * Inserts `node` before `child` in this node. If `child` is `none`, the
	 * is inserted as the first child element.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def insertBefore(self, node, child = none) {
		var index = defined child ? self.children.indexOf(child) : 0
		if not defined index {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_FOUND_ERR)
		}
		self.insert(index, node)
		return node
	}

	/**
	 * Inserts the node `node` at the index given by `index`. If `index` is
	 * negative, the position is relative to the end of this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def insert(self, index, node) {
		if typeof self not in ('Serializer.XmlDomDocument', 'Serializer.XmlDomElement') {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if not Serializer.XmlDomCharacterData.isBaseOf(node) and typeof node not in ('Serializer.XmlDomElement', 'Serializer.XmlDomDtd') {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomText' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomDtd' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		self.children.insert(index, node)
		node.parent = self
	}

	/**
	 * Appends `node` at the end of this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def appendChild(self, node) {
		if typeof self not in ('Serializer.XmlDomDocument', 'Serializer.XmlDomElement') {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if not Serializer.XmlDomCharacterData.isBaseOf(node) and typeof node not in ('Serializer.XmlDomElement', 'Serializer.XmlDomDtd') {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomText' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomDtd' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		self.children << node
		node.parent = self
		return node
	}

	/**
	 * Replaces the `child` node with `node` in this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def replaceChild(self, node, child) {
		var index = self.children.indexOf(child)
		if not defined index {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_FOUND_ERR)
		}
		self.replace(index, node)
		return node
	}

	/**
	 * Replaces the node at the given `index` with `node` in this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def replace(self, index, node) {
		if not Serializer.XmlDomCharacterData.isBaseOf(node) and typeof node not in ('Serializer.XmlDomElement', 'Serializer.XmlDomDtd') {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomText' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		if typeof node == 'Serializer.XmlDomDtd' and typeof self != 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		self.children[index] = node
		node.parent = self
	}

	/**
	 * Removes `node` from this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def removeChild(self, node) {
		var index = self.children.indexOf(child)
		if not defined index {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_FOUND_ERR)
		}
		self.remove(index)
		return node
	}

	/**
	 * Removes the node at the given `index` from this node.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def remove(self, index) {
		self.children[index].parent = null
		self.children.remove(index)
	}

	/**
	 * Returns the fisrt node where `predicate` returns `true` for the node. The
	 * nodes are searched recursively in this node's children. If no matching
	 * node can be found `none` is returned.
	 */
	# const def findRecursive(const self, predicate) {
		for var child in children {
			if predicate(child) {
				return child
			}
			if let var node = child.findRecursive(predicate) {
				return node
			}
		}
	}

	/// Internal document node.
	# final document = null

	/// Internal parent node.
	# final parent = null

	/// Internal child node list.
	# final children = []
}

/**
 * This class represents the entire XML document. Conceptually, it is the root
 * of the document tree, and provides the primary access to the document's data.
 */
class XmlDomDocument : Serializer.XmlDomNode {
	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		var clone = Serializer.XmlDomDocument()
		if deep {
			for var child in self.children {
				clone.children << child.cloneNode(deep)
			}
		}
		return clone
	}

	/**
	 * Returns an iterator on each top level {Serializer.XmlDomProcessingInstruction}
	 * of the document.
	 */
	const def getProcessingInstructions(const self) {
		for var node in self.children {
			if typeof node == 'Serializer.XmlDomProcessingInstruction' {
				yield node
			}
		}
	}

	/**
	 * Returns the document type of this document.
	 */
	const def getDoctype(const self) {
		for var node in self.children {
			if typeof node == 'Serializer.XmlDomDtd' {
				return node
			}
		}
	}

	/**
	 * Returns the root element of the document.
	 */
	const def getDocumentElement(const self) {
		for var node in self.children {
			if typeof node == 'Serializer.XmlDomElement' {
				return node
			}
		}
	}

	/**
	 * Returns an iterator on each top level child {Serializer.XmlDomElement}
	 * with a name that match `qualifiedName`.
	 */
	const def getElementsByTagName(const self, qualifiedName) {
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
					if localName == child.getQualifiedName() {
					yield child
				}
			}
			for let var node in child.getElementsByTagName(qualifiedName) {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each top level child {Serializer.XmlDomElement}
	 * with a name that match `namespaceUri` and `localName`.
	 */
	const def getElementsByTagNameNS(const self, namespaceUri, localName) {
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
				if namespaceUri == child.getNamespaceUri() and localName == child.getLocalName() {
					yield child
				}
			}
			for let var node in child.getElementsByTagNameNS(namespaceUri, localName) {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each descendants elements of this node with all
	 * their classes contained in `classNames`. The `classNames` parameter can
	 * either be an array of names or a string containing each names separated
	 * with white spaces.
	 */
	const def getElementsByClassName(const self, classNames) {
		if typeof classNames == 'string' {
			className = classNames.split(/\s+/)
		}
		const classNamesMatch = def (const self, const other) {
			for var nane in self {
				if name not in other {
					return false
				}
			}
			return true
		}
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
				if child.getClassList().classNamesMatch(classNames) {
					yield child
				}
				for let var node in child.getElementsByClassName() {
					yield node
				}
			}
		}
	}

	/**
	 * Returns the first element within node’s descendants whose ID is
	 * `elementId` or `null` if no matching element can be found.
	 */
	const def getElementById(const self, elementId) {
		if var node = self.findRecursive(def [elementId] (node) { return typeof node == 'Serializer.XmlDomElement' and elementId == node.getId() }) {
			return node
		}
		return null
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomElement} with the givens
	 * `qualifiedlName` and `attributes` for this document.
	 */
	const def createElement(self, qualifiedlName, attributes = Serializer.XmlAttributes()) {
		var node = Serializer.XmlDomElement(localName)
		for var attr in attributes {
			node.setAttributeNode(attr)
		}
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomElement} with the givens
	 * `namespaceUri`, `qualifiedlName` and `attributes` for this document.
	 */
	const def createElementNS(self, namespaceUri, qualifiedName, attributes = Serializer.XmlAttributes()) {
		var node = Serializer.XmlDomElement(namespaceUri, qualifiedName)
		for var attr in attributes {
			node.setAttributeNode(attr)
		}
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomDocument} for this document.
	 */
	const def createDocumentFragment(self) {
		var node = Serializer.XmlDomDocumentFragment()
		node.document = self
		return node
	}
	
	/**
	 * Creates a new instance of {Serializer.XmlDomText} with the given `data`
	 * for this document.
	 */
	const def createTextNode(self, data) {
		var node = Serializer.XmlDomText(data)
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomCData} with the given `data`
	 * for this document.
	 */
	const def createCDATASection(self, data) {
		var node = Serializer.XmlDomCData(data)
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomComment} with the given `data`
	 * for this document.
	 */
	const def createComment(self, data) {
		var node = Serializer.XmlDomComment(data)
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomProcessingInstruction} with
	 * the givens `target` and `data` for this document.
	 */
	const def createProcessingInstruction(self, target, data) {
		var node = Serializer.XmlDomProcessingInstruction(target, data)
		node.document = self
		return node
	}

	/**
	 * Returns a copy of `node`. If `deep` is `true`, the copy also includes the
	 * `node`’s descendants.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def importNode(self, node, deep = false) {
		if typeof node == 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR)
		}
		var clone = node.cloneNode(deep)
		clone.document = self
		return clone
	}

	/**
	 * Moves `node` from another document and returns it.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def adoptNode(self, node) {
		if typeof node == 'Serializer.XmlDomDocument' {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR)
		}
		if node.parent {
			node.parent.removeChild(node)
		}
		node.document = self
		for var child in node.children {
			node.appendChild(self.adoptNode(child))
		}
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomAttribute} with the given
	 * `qualifiedlName` for this document.
	 */
	const def createAttribute(self, qualifiedName) {
		var node = Serializer.XmlDomAttribute(qualifiedName)
		node.document = self
		return node
	}

	/**
	 * Creates a new instance of {Serializer.XmlDomAttribute} with the givens
	 * `namespaceUri` and `qualifiedlName` for this document.
	 */
	const def createAttributeNS(self, namespaceUri, qualifiedName) {
		var node = Serializer.XmlDomAttribute(namespaceUri, qualifiedName)
		node.document = self
		return node
	}

	/**
	 * Returns the string representation of the document.
	 */
	const def toString(const self) {
		var str = ''
		for var child in self.children {
			str << child.toString()
		}
		return str
	}
}

/**
 * This class represents a fragment of the DOM tree.
 */
class XmlDomDocumentFragment : Serializer.XmlDomNode {
	/**
	 * Returns the first element within node’s descendants whose ID is
	 * `elementId` or `null` if no matching element can be found.
	 */
	const def getElementById(const self, elementId) {
		if var node = self.findRecursive(def [elementId] (node) { return typeof node == 'Serializer.XmlDomElement' and elementId == node.getId() }) {
			return node
		}
		return null
	}

	/**
	 * Returns the node's text content by concatenating its meaningfull value
	 * with the value of each its descendants recursively.
	 */
	override const def getTextContent(const self) {
		var text = ''
		for var child in self.children {
			if let var childText = child.getTextContent() {
				text << childText
			}
		}
		return text
	}

	/**
	 * Returns the string representation of the document fragment.
	 */
	const def toString(const self) {
		var str = ''
		for var child in self.children {
			str << child.toString()
		}
		return str
	}

}

/**
 * This class represents one attribute in the DOM tree.
 */
class XmlDomAttribute : Serializer.XmlDomNode {
	/**
	 * Creates a new attribute from {Serializer.XmlAttribute} `attribute`.
	 */
	const def new(self, attribute) {
		self.attribute = attribute
		return self
	}

	/**
	 * Creates a new attribute with the given `qualifiedName` and `value`.
	 */
	const def new(self, qualifiedName, value) {
		self.attribute = Serializer.XmlAttribute(qualifiedName, value)
		return self
	}

	/**
	 * Creates a new attribute with the given `namespaceUri`, `qualifiedName`
	 * and `value`.
	 */
	const def new(self, namespaceUri, qualifiedName, value) {
		self.attribute = Serializer.XmlAttribute(namespaceUri, qualifiedName, value)
		return self
	}

	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		var clone = self.document.createAttributeNS(self.attribute.getNamespaceUri(), self.attribute.getQualifiedName())
		clone.attribute.setValue(self.attribute.getValue())
		return clone
	}

	/**
	 * Returns the namespace URI of the attribute.
	 */
	const def getNamespaceUri(const self) {
		return self.attribute.getNamespaceUri()
	}

	/**
	 * Returns the local name of the attribute.
	 */
	const def getLocalName(const self) {
		return self.attribute.getLocalName()
	}

	/**
	 * Returns the qualified name of the attribute (prefix + name).
	 */
	const def getQualifiedName(const self) {
		return self.attribute.getQualifiedName()
	}

	/**
	 * Returns the prefix (namespace) of the attribute.
	 */
	const def getPrefix(const self) {
		return self.attribute.getPrefix()
	}

	/**
	 * Returns the value of the attribute.
	 */
	const def getValue(const self) {
		return self.attribute.getValue()
	}

	/**
	 * Returns the node's meaningfull value.
	 */
	override const def getNodeValue(const self) {
		return self.getValue()
	}

	/**
	 * Returns the node's text content by concatenating its meaningfull value
	 * with the value of each its descendants recursively.
	 */
	override const def getTextContent(const self) {
		return self.getValue()
	}

	/**
	 * Returns the owner element of the attribute.
	 */
	const def getOwnerElement(const self) {
		return typeof self.parent == 'Serializer.XmlDomElement' ? self.parent : null
	}

	/**
	 * Returns the string representation of the attribute.
	 */
	const def toString(const self) {
		return self.attribute.toString()
	}

	// Internal attribute object.
	- final attribute = null
}

/**
 * This class represents an attribute list in the DOM tree.
 */
class XmlDomNamedNodeMap {
	/**
	 * Creates a new attribute list.
	 */
	const def new(self) {
		return self
	}

	/**
	 * Returns `true` if `other` is equal to this list of attributes; otherwise
	 * returns `false`.
	 * 
	 * Two lists are considered equal if they contain the same attributes in the
	 * same order.
	 */
	const def ==(const self, const other) {
		return self.attributes == other.attributes
    }

	/**
	 * Returns `true` if `other` is not equal to this list of attributes; otherwise
	 * returns `false`.
	 * 
	 * Two lists are considered equal if they contain the same attributes in the
	 * same order.
	 */
	const def !=(const self, const other) {
		return self.attributes != other.attributes
	}

	/**
	 * Returns `true` if the list contains an attribute with the given
	 * `qualifiedName`; otherwise returns `false`.
	 */
	const def in(const self, const qualifiedName) {
		return self.contains(qualifiedName)
	}

	/**
	 * Returns an `iterator` on each attribute of the list.
	 */
	const def in(const self) {
		for var attr in self.attributes {
			yield attr
		}
	}

	/**
	 * Returns the number of attributes in the list.
	 */
	const def length(const self) {
		return self.attributes.size()
	}

	/**
	 * Returns the number of attributes in the list.
	 */
	const def size(const self) {
		return self.attributes.size()
	}

	/**
	 * Returns `true` if the list is empty; otherwise returns `false`.
	 */
	const def isEmpty(const self) {
		return self.attributes.isEmpty()
	}

	/**
	 * Returns `true` if the list contains an attribute with the given
	 * `qualifiedName`; otherwise returns `false`.
	 */
	const def contains(const self, const qualifiedName) {
		for var attr in self.attributes {
            if qualifiedName == attr.getQualifiedName() {
                return true
            }
        }
		return false
	}

	/**
	 * Returns `true` if the list contains an attribute with the givens
	 * `namespaceUri` and `localName`; otherwise returns `false`.
	 */
	const def containsNS(const self, namespaceUri, const localName) {
        for var attr in self.attributes {
            if namespaceUri == attr.getNamespaceUri() and localName == attr.getLocalName() {
                return true
            }
        }
		return false
    }

	/**
	 * Returns the attribute at the given `index` in the list or `null` if no
	 * attribute can be found.
	 */
	const def item(const self, index) {
		if 0 <= index and index < self.attribute.size() {
			return self.attribute[index]
		}
		return null
	}

	/**
	 * Returns the first attribute with the given `qualifiedName`; otherwise
	 * `null`.
	 */
	const def getNamedItem(const self, const qualifiedName) {
		for var attr in self.attributes {
            if qualifiedName == attr.getQualifiedName() {
                return attr
            }
        }
		return null
	}

	/**
	 * Returns the first attribute with the givens `namespaceUri` and
	 * `localName`; otherwise `null`.
	 */
	const def getNamedItemNS(const self, namespaceUri, const localName) {
        for var attr in self.attributes {
            if namespaceUri == attr.getNamespaceUri() and localName == attr.getLocalName() {
                return attr
            }
        }
		return null
    }

	/**
	 * Sets the attribute `attr` into the list. If an attribute with the same
	 * qualified name is found in the list, the attribute is replaced with the
	 * new value and the previous instance is returned; otherwise the node is
	 * inserted at the end of the list and `null` is returned.
	 */
	const def setNamedItem(self, attr) {
		if not attr.getOwnerElement() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		var index = self.indexOf(attr.getQualifiedName())
		if defined index {
			var oldAttr = self.attributes[index]
			self.attributes[index] = attr
			return oldAttr
		}
		self.attributes << attr
		return null
	}

	/**
	 * Sets the attribute `attr` into the list. If an attribute with the same
	 * namespace URI and local name is found in the list, the attribute is
	 * replaced with the new value and the previous instance is returned;
	 * otherwise the node is inserted at the end of the list and `null` is
	 * returned.
	 */
	const def setNamedItemNS(self, attr) {
		if not attr.getOwnerElement() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.HIERARCHY_REQUEST_ERR)
		}
		var index = self.indexOfNS(attr.getNamespaceUri(), attr.getLocalName())
		if defined index {
			var oldAttr = self.attributes[index]
			self.attributes[index] = attr
			return oldAttr
		}
		self.attributes << attr
		return null
	}

	/**
	 * Removes the first attribute with the given `qualifiedName`.
	 */
	const def removeNamedItem(self, const qualifiedName) {
		if isDefined(var index = self.indexOf(qualifiedName)) {
			self.attributes.remove(index)
		}
	}
	
	/**
	 * Removes the first attribute with the givens `namespaceUri` and
	 * `localName`.
	 */
	const def removeNamedItemNS(self, const namespaceUri, const localName) {
		if isDefined(var index = self.indexOfNS(namespaceUri, localName)) {
			self.attributes.remove(index)
		}
	}

	/**
	 * Returns the index position of the first attribute with the given
	 * `qualifiedName`. Returns `none` if no element matched.
	 */
	const def indexOf(const self, const qualifiedName) {
		for var index in 0...self.attributes.size() {
			let var attr = self.attributes[index]
			if qualifiedName == attr.getQualifiedName() {
                return index
            }
		}
	}

	/**
	 * Returns the index position of the first attribute with the givens
	 * `namespaceUri` and `localName`. Returns `none` if no element matched.
	 */
	const def indexOfNS(const self, const namespaceUri, const localName) {
		for var index in 0...self.attributes.size() {
			let var attr = self.attributes[index]
			if namespaceUri == attr.getNamespaceUri() and localName == attr.getLocalName() {
                return index
            }
		}
	}

	/**
	 * Returns the string representation of the attribute list.
	 */
	const def toString(const self) {
		var str = ''
		for var attr in self.attributes {
			str << ' ' << attr.toString()
		}
		return str
	}

	/// Internal attributes.
	- final attributes = []
}

/**
 * This class represents one element in the DOM tree. An element have a tag name
 * and zero or more attributes. It can also contains children nodes.
 */
class XmlDomElement : Serializer.XmlDomNode {
	/**
	 * Creates a new element with the given `qualifiedName`.
	 */
	const def new(self, qualifiedName) {
		self.qualifiedName = qualifiedName
		self.attributes = Serializer.XmlDomNamedNodeMap()
		if isDefined(var pos = qualifiedName.indexOf(':')) {
			self.namespaceUri = qualifiedName[0...pos]
			self.localName = qualifiedName[(pos + 1)...qualifiedName.size()]
		} else {
			self.localName = qualifiedName
		}
		return self
	}

	/**
	 * Creates a new element with the given `namespaceUri` and `qualifiedName`.
	 */
	const def new(self, namespaceUri, qualifiedName) {
		self.namespaceUri = namespaceUri
		self.qualifiedName = qualifiedName
		self.attributes = Serializer.XmlDomNamedNodeMap()
		if isDefined(var pos = qualifiedName.indexOf(':')) {
			self.localName = qualifiedName[(pos + 1)...qualifiedName.size()]
		} else {
			self.localName = qualifiedName
		}
		return self
	}

	/**
	 * Returns `true` if `other` is equal to `self`; otherwise returns `false`.
	 */
	override const def ==(const self, const other) {
		if not Serializer.XmlDomNode.==(self, other) {
			return false
		}
		if (not defined self.namespaceUri or self.namespaceUri.isEmpty()) \
				? (self.qualifiedName != other.qualifiedName) \
				: (self.namespaceUri != other.namespaceUri or self.localName != other.localName) {
			return false
		}
		if self.attributes != other.attributes {
			return false
		}
		return true
	}

	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		var clone = self.document.createElementNS(self.namespaceUri, self.qualifiedlName)
		for var attr in self.attributes {
			clone.setAttributeNode(attr.cloneNode())
		}
		if deep {
			for var child in self.children {
				clone.children << child.cloneNode(deep)
			}
		}
		return clone
	}

	/**
	 * Returns the namespace URI of the tag.
	 */
	const def getNamespaceUri(const self) {
		return self.namespaceUri
	}

	/**
	 * Returns the name of the tag.
	 */
	const def getLocalName(const self) {
		return self.localName
	}

	/**
	 * Returns the qualified name of the tag (prefix + name).
	 */
	const def getTagName(const self) {
		return self.qualifiedName
	}

	/**
	 * Returns the prefix (namespace) of the tag.
	 */
	const def getPrefix(const self) {
		return self.qualifiedName[0...max(0, self.qualifiedName.size() - self.localName.size() - 1)]
	}

	/**
	 * Returns the value of the `id` attribute of the element or `none` if the
	 * element has no ID.
	 */
	const def getId(const self) {
		return self.getAttribute('id')
	}

	/**
	 * Returns the value of the `class` attribute of the element or `none` if
	 * the element has no class name.
	 */
	const def getClassName(const self) {
		return self.getAttribute('class')
	}

	/**
	 * Returns an array containing the list of values in the `class` attribute
	 * of the element or an empty list if the element has no class name.
	 */
	const def getClassList(const self) {
		var className = self.getAttribute('class')
		if defined className {
			return className.split(/\s+/)
		}
		return []
	}

	/**
	 * Returns the value of the `slot` attribute of the element or `none` if
	 * the element has no class slot.
	 */
	const def getSlot(const self) {
		return self.getAttribute('slot')
	}

	/**
	 * Returns the node's text content by concatenating its meaningfull value
	 * with the value of each its descendants recursively.
	 */
	override const def getTextContent(const self) {
		var text = ''
		for var child in self.children {
			if let var childText = child.getTextContent() {
				text << childText
			}
		}
		return text
	}

	/**
	 * Returns `true` if the element has attributes; otherwise `false`. 
	 */
	const def hasAttributes(const self) {
		return not self.attributes.isEmpty()
	}

	/**
	 * Returns an instance of {Serializer.XmlAttributes} containing each
	 * attributes of the element.
	 */
	const def getAttributes(const self) {
		return self.attributes
	}

	/**
	 * Returns an iterator on each element's attribute's qualified name.
	 */
	const def getAttributeNames(const self) {
		for var attr in self.attributes {
			yield attr.getQualifiedName()
		}
	}

	/**
	 * Returns the attribute with the given `qualifiedName`.
	 */
	const def getAttribute(const self, qualifiedName) {
		return self.attributes.getNamedItem(qualifiedName)
	}

	/**
	 * Returns the attribute with the given `namespaceUri` and `localName`.
	 */
	const def getAttributeNS(const self, namespaceUri, localName) {
		return self.attributes.getNamedItemNS(namespaceUri, localName)
	}

	/**
	 * Sets the value of the attribute with the given `qualifiedName` to `value`.
	 * If no attribute was found, a new attribute is created at the end of the
	 * list.
	 */
	const def setAttribute(self, qualifiedName, value) {
		var attr = self.document.createAttribute(qualifiedName, value)
		attr.parent = self
		self.attributes.setNamedItem(attr)
	}

	/**
	 * Sets the value of the attribute with the given `namespaceUri` and
	 * `qualifiedName` to `value`. If no attribute was found, a new attribute
	 * is created at the end of the list.
	 */
	const def setAttributeNS(self, namespaceUri, qualifiedName, value) {
		var attr = self.document.createAttributeNS(namespaceUri, qualifiedName, value)
		attr.parent = self
		self.attributes.setNamedItemNS(attr)
	}

	/**
	 * Removes the attribute with the given `qualifiedName` from this element.
	 */
	const def removeAttribute(self, qualifiedName) {
		self.attributes.removeNamedItem(qualifiedName)
	}

	/**
	 * Removes the attribute with the given `namespaceUri` and `localName` from this element.
	 */
	const def removeAttributeNS(self, namespaceUri, localName) {
		self.attributes.removeNamedItemNS(namespaceUri, localName)
	}

	/**
	 * Toggles the attribute with the given qualifiedName`, removing it if it
	 * is present and adding it if it is not present.
	 * 
	 * Returns `true` if the attribute is now present; otherwise false.
	 */
	const def toggleAttribute(self, qualifiedName) {
		if self.attributes.contains(qualifiedName) {
			self.attributes.removeNamedItem(qualifiedName)
			return false
		} else {
			var attr = self.document.createAttribute(qualifiedName, '')
			attr.parent = self
			self.attributes.setNamedItem(attr)
			return true
		}
	}
	/**
	 * If `force` is `true`, adds an attribute with the given qualifiedName`.
	 * If `force` is `false`, removes the attribute with the given qualifiedName`.
	 * 
	 * Returns `true` if the attribute is now present; otherwise false.
	 */
	const def toggleAttribute(self, qualifiedName, force) {
		if force {
			if not self.attributes.contains(qualifiedName) {
				var attr = self.document.createAttribute(qualifiedName, '')
				attr.parent = self
				self.attributes.setNamedItem(attr)
			}
			return true
		} else {
			self.attributes.removeNamedItem(qualifiedName)
			return false
		}
	}

	/**
	 * Returns `true` if this element has an attribute with the given
	 * `qualifiedName`; otherwise returns `false`.
	 */
	const def hasAttribute(const self, qualifiedName) {
		return self.attributes.contains(qualifiedName)
	}

	/**
	 * Returns `true` if this element has an attribute with the given
	 * `namespaceUri` and `localName`; otherwise returns `false`.
	 */
	const def hasAttributeNS(const self, namespaceUri, localName) {
		return self.attributes.containsNS(namespaceUri, localName)
	}

	/**
	 * Returns the first attribute with the given `qualifiedName`; otherwise
	 * `null`.
	 */
	const def getAttributeNode(const self, qualifiedName) {
		return self.attributes.getNamedItem(qualifiedName)
	}

	/**
	 * Returns the first attribute with the givens `namespaceUri` and
	 * `localName`; otherwise `null`.
	 */
	const def getAttributeNodeNS(const self, namespaceUri, localName) {
		return self.attributes.getNamedItemNS(namespaceUri, localName)
	}

	/**
	 * Sets the attribute `attr` into the list. If an attribute with the same
	 * qualified name is found in the list, the attribute is replaced with the
	 * new value and the previous instance is returned; otherwise the node is
	 * inserted at the end of the list and `null` is returned.
	 */
	const def setAttributeNode(self, attr) {
		if var owner = attr.getOwnerElement() and not self.isSameNode(owner) {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INUSE_ATTRIBUTE_ERR)
		}
		attr.parent = self
		return self.attributes.setNamedItem(attr)
	}

	/**
	 * Sets the attribute `attr` into the list. If an attribute with the same
	 * namespace URI and local name is found in the list, the attribute is
	 * replaced with the new value and the previous instance is returned;
	 * otherwise the node is inserted at the end of the list and `null` is
	 * returned.
	 */
	const def setAttributeNodeNS(self, attr) {
		if var owner = attr.getOwnerElement() and not self.isSameNode(owner) {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INUSE_ATTRIBUTE_ERR)
		}
		attr.parent = self
		return self.attributes.setNamedItemNS(attr)
	}

	/**
	 * Removes the attribute `attr` from the list and returns it. The list must
	 * contains an attribute with the same qualified name. 
	 */
	const def removeAttributeNode(self, attr) {
		if not self.attribute.removeNamedItem(attr.getQualifiedName()) {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_FOUND_ERR)
		}
		return attr
	}
	
	/**
	 * Removes the attribute `attr` from the list and returns it. The list must
	 * contains an attribute with the same namespace URI and local name. 
	 */
	const def removeAttributeNodeNS(self, attr) {
		if not self.attribute.removeNamedItemNS(attr.getNamespaceUri(), attr.getLocalName()) {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_FOUND_ERR)
		}
		return attr
	}

	/**
	 * Returns an iterator on each direct child {Serializer.XmlDomElement} with
	 * a name that match `qualifiedName`.
	 */
	const def getElementsByTagName(const self, qualifiedName) {
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
					if localName == child.getQualifiedName() {
					yield child
				}
			}
			for let var node in child.getElementsByTagName(qualifiedName) {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each direct child {Serializer.XmlDomElement} with
	 * a name that match `namespaceUri` and `localName`.
	 */
	const def getElementsByTagNameNS(const self, namespaceUri, localName) {
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
				if namespaceUri == child.getNamespaceUri() and localName == child.getLocalName() {
					yield child
				}
			}
			for let var node in child.getElementsByTagNameNS(namespaceUri, localName) {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each descendants elements of this node with all
	 * their classes contained in `classNames`. The `classNames` parameter can
	 * either be an array of names or a string containing each names separated
	 * with white spaces.
	 */
	const def getElementsByClassName(const self, classNames) {
		if typeof classNames == 'string' {
			className = classNames.split(/\s+/)
		}
		const classNamesMatch = def (const self, const other) {
			for var nane in self {
				if name not in other {
					return false
				}
			}
			return true
		}
		for var child in self.children {
			if typeof child == 'Serializer.XmlDomElement' {
				if child.getClassList().classNamesMatch(classNames) {
					yield child
				}
				for let var node in child.getElementsByClassName() {
					yield node
				}
			}
		}
	}

	/**
	 * Returns the string representation of the element.
	 */
	const def toString(const self) {
		
		if self.children.isEmpty() {
			return '<%s%s/>' % (self.localName, self.attributes.toString())
		}

		var str = '<%s%s>' % (self.localName, self.attributes.toString())
		for var child in self.children {
			str << child.toString()
		}
		str << '</%s>' % self.localName
		return str
	}

	/// Internal tag name.
	- final localName = ''

	/// Internal tag namespace URI.
	- final namespaceUri = ''

	/// Internal tag qualified name.
	- final qualifiedName = ''

	/// Internal attributes list.
	- final attributes = null
}

/**
 * This class represents abstract character data in the parsed XML document.
 */
class XmlDomCharacterData : Serializer.XmlDomNode {
	/**
	 * Creates a new character node for the characters given by `data`.
	 */
	const def new(self, data) {
		self.data = trim(data)
		return self
	}

	/**
	 * Returns `true` if `other` is equal to `self`; otherwise returns `false`.
	 */
	override const def ==(const self, const other) {
		if not Serializer.XmlDomNode.==(self, other) {
			return false
		}
		if self.data != other.data {
			return false
		}
		return true
	}

	/**
	 * Returns the node's meaningfull value.
	 */
	override const def getNodeValue(const self) {
		return self.getData()
	}

	/**
	 * Returns the node's text content by concatenating its meaningfull value
	 * with the value of each its descendants recursively.
	 */
	override const def getTextContent(const self) {
		return self.getData()
	}

	/**
	 * Returns the content of the text node.
	 */
	const def getData(const self) {
		return self.data
	}

	/**
	 * Sets the content of the text node.
	 */
	const def setData(self, content) {
		self.data = data
	}

	/**
	 * Returns the length of the data.
	 */
	const def length(const self) {
		return self.data.size()
	}

	/**
	 * Returns the length of the data.
	 */
	const def size(const self) {
		return self.data.size()
	}

	/**
	 * Returns the substring of length `count` from position `offset`.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def substringData(const self, offset, count) {
		if 0 > offset or offset >= self.data.size() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INDEX_SIZE_ERR)
		}
		const stop = min(offset + count, self.data.size())
		return self.data[offset...stop]
	}

	/**
	 * Appends the string `data` to the stored string.
	 */
	const def appendData(self, data) {
		self.data << data
	}

	/**
	 * Inserts the string `data` into the stored string at position `offset`.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def insertData(self, offset, data) {
		if 0 > offset or offset >= self.data.size() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INDEX_SIZE_ERR)
		}
		self.data.insert(offset, data)
	}

	/**
	 * Deletes a substring of length `count` from position `offset`.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def deleteData(self, offset, count) {
		if 0 > offset or offset >= self.data.size() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INDEX_SIZE_ERR)
		}
		const stop = min(offset + count, self.data.size())
		self.data[offset...stop] = ''
	}

	/**
	 * Replaces the substring of length `count` starting at position `offset`
	 * with the string `data`.
	 * 
	 * An instance of {Serializer.XmlDomException} is raised on error.
	 */
	const def replaceData(self, offset, count, data) {
		if 0 > offset or offset >= self.data.size() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INDEX_SIZE_ERR)
		}
		const stop = min(offset + count, self.data.size())
		self.data[offset...stop] = data
	}

	/// Internal content data.
	# final data = ''
}

/**
 * This class represents an XML processing instruction. A processing instruction
 * have a target name and one or more ettributes.
 */
class XmlDomProcessingInstruction : Serializer.XmlDomCharacterData {
	/**
	 * Creates a new processing instruction with the given `name` target name
	 * and `data` attribute list.
	 */
	const def new(self, target, data) {
		if self = Serializer.XmlDomCharacterData(self, trim(data.toString())) {
			self.target = target
			if typeof data == 'Serializer.XmlAttributes' {
				self.attributes = data
			}
			return self
		}
	}

	/**
	 * Returns `true` if `other` is equal to `self`; otherwise returns `false`.
	 */
	override const def ==(const self, const other) {
		if not Serializer.XmlDomCharacterData.==(self, other) {
			return false
		}
		if self.target != other.target {
			return false
		}
		return true
	}

	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		return self.document.createProcessingInstruction(self.target, self.getData())
	}

	/**
	 * Returns the target name of the processing instruction.
	 */
	const def getTarget(const self) {
		return self.target
	}

	/**
	 * Sets the target name of the processing instruction.
	 */
	const def setTarget(self, target) {
		self.target = name
	}

	/**
	 * Returns `true` if this element has an attribute with the given
	 * `qualifiedName`; otherwise returns `false`.
	 */
	const def hasAttribute(const self, qualifiedName) {
		if defined self.attributes {
			return self.attributes.contains(qualifiedName)
		}
		return false
	}

	/**
	 * Returns an instance of {Serializer.XmlAttributes} containing each
	 * attributes of the processing instruction data or `none` if the data is
	 * not an attribute list.
	 */
	const def getAttributes(const self) {
		return self.attributes
	}

	/**
	 * Returns the attribute with the given `qualifiedName`.
	 */
	const def getAttribute(const self, qualifiedName) {
		if not defined self.attributes {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR)
		}
		return self.attributes.get(qualifiedName)
	}

	/**
	 * Sets the value of the attribute with the given `qualifiedName` to `value`.
	 * If no attribute was found, a new attribute is created at the end of the
	 * list.
	 */
	const def setAttribute(self, qualifiedName, value) {
		if not defined self.attributes {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR)
		}
		if var attr = self.attribute.get(qualifiedName) {
			attr.setValue(value)
		} else {
			self.attributes << Serializer.XmlAttribute(qualifiedName, value)
		}
		self.data = trim(self.attributes.toString())
	}

	/**
	 * Removes the attribute with the given `qualifiedName` from this element.
	 */
	const def removeAttribute(self, qualifiedName) {
		if not defined self.attributes {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.NOT_SUPPORTED_ERR)
		}
		self.attributes.remove(qualifiedName)
		self.data = trim(self.attributes.toString())
	}

	/**
	 * Returns the string representation of the processing instruction.
	 */
	const def toString(const self) {
		return '<?%s %s?>' % (self.name, self.data)
	}

	/// Internal target name.
	- final target = ''

	/// Internal attributes list.
	- final attributes = none
}

/**
 * This class represents text data in the parsed XML document.
 */
class XmlDomText : Serializer.XmlDomCharacterData {
	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		return self.document.createTextNode(self.getData())
	}

	/**
	 * Splits data at the given `offset` and returns the remainder as
	 * {Serializer.XmlDomText} node. 
	 */
	const def splitText(const self, offset) {
		if 0 > offset or offset >= self.data.size() {
			raise Serializer.XmlDomException(Serializer.XmlDomException.Code.INDEX_SIZE_ERR)
		}
		var node = self.document.createTextNode(self.data[offset...self.data.size()])
		node.parent = self.parent
		return node
	}

	/**
	 * Returns the combined data of all direct {Serializer.XmlDomText} node
	 * siblings.
	 */
	const def wholeText(const self) {
		var text = ''
		for var node in self.parent.children {
			if typeof node == 'Serializer.XmlDomText' {
				text << node.getData()
			}
		}
		return text
	}
	
	/**
	 * Returns the string representation of the text node.
	 */
	const def toString(const self) {
		return Serializer.XmlStream.escapeString(self.getData())
	}
}

/**
 * This class represents comment data in the parsed XML document.
 */
class XmlDomComment : Serializer.XmlDomCharacterData {
	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		return self.document.createComment(self.getData())
	}

	/**
	 * Returns the string representation of the comment node.
	 */
	const def toString(const self) {
		return '<!--%s-->' % self.getData()
	}
}

/**
 * This class represents an XML CDATA section.
 * 
 * CDATA sections are used to escape blocks of text containing characters that
 * would otherwise be regarded as markup. The only delimiter that is recognized
 * in a CDATA section is the `]]>` string that terminates the CDATA section.
 * 
 * CDATA sections cannot be nested. Their primary purpose is for including
 * material such as XML fragments, without needing to escape all the delimiters.
 */
class XmlDomCData : Serializer.XmlDomCharacterData {
	/**
	 * Returns the string representation of the CDATA node.
	 */
	const def toString(const self) {
		return '<![CDATA[%s]]>' % self.getData()
	}
}

/**
 * This class is the representation of the DTD in the document tree.
 */
class XmlDomDtd : Serializer.XmlDomNode {
	/**
	 * Creates a new DTD node for the text given by `content`.
	 */
	const def new(self, content) {
		self.content = trim(content)
		return self
	}

	/**
	 * Returns `true` if `other` is equal to `self`; otherwise returns `false`.
	 */
	override const def ==(const self, const other) {
		if not Serializer.XmlDomNode.==(self, other) {
			return false
		}
		if self.content != other.content {
			return false
		}
		return true
	}

	/**
	 * Returns a copy of this node. If `deep` is `true`, the copy also includes
	 * the node’s descendants. 
	 */
	override const def cloneNode(self, deep = false) {
		var clone = Serializer.XmlDomDtd(self.content)
		clone.document = self.document
		return clone
	}

	/**
	 * Returns the string representation of the DTD node.
	 */
	const def toString(const self) {
		return '<!DOCTYPE %s>' % self.content
	}

	/// Internal content data.
	- final content = ''
}

}
