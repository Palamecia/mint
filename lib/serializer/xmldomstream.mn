/**
 * This module provides the {XmlDomStream} class which allow to read and write XML
 * documents with a DOM algorithm.
 */

load serializer.xmlsaxstream
load mint.string
load mint.hash
load mint.type
load mint.lang

/**
 * This class class provides a way to read and write XML documents using a DOM
 * algorithm.
 */
class XmlDomStream : XmlSaxStream {
	/**
	 * Creates a new stream for reading and writing data using `stream`.
	 */
	const def new(self, stream) {
		if self = XmlSaxStream.new(self, stream) {
			self.context = XmlDomStream.Context()
			self.setHandle(XmlDomStream.SaxToDomHandle(self.context))
			return self
		}
	}

	/**
	 * Reads the content of the stream and return it as an instance of
	 * {XmlDomDocument}. If the content of the stream is not a valid XML, an
	 * instance of {DocumentStream.InvalidDocument} is raised.
	 */
	const def read(self) {
		if XmlSaxStream.read(self) {
			return self.context.document
		}
	}

	/**
	 * Returns the handle used to handle XML content.
	 */
	- const def getHandle(const self) {
		return XmlSaxStream.getHandle(self)
	}

	/**
	 * Sets the handle used to handle XML content.
	 */
	- const def setHandle(self, handle) {
		XmlSaxStream.setHandle(self, handle)
	}

	/**
	 * This class provides the parsing context of a {XmlDomStream}.
	 */
	- class Context {

		/// Current document node.
		document = none

		/// Current element stack.
		elements = []

		/**
		 * Adds element `element` to the top of the stack.
		 */
		const def pushElement(self, element) {
			self.elements << element
		}

		/**
		 * Removes the top element from the stack and returns it. This function
		 * assumes that the stack is not empty.
		 */
		const def popElement(self) {
			var element = self.elements[-1]
			self.elements.remove(-1)
			return element
		}

		/**
		 * Returns the stack's top element. This function assumes that the stack
		 * is not empty.
		 */
		const def topElement(const self) {
			return self.elements[-1]
		}

		/**
		 * Returns the stack's top element if any or the document root node.
		 */
		const def topParent(const self) {
			if self.elements.isEmpty() {
				return self.document
			}
			return self.elements[-1]
		}
	}

	/**
	 * This class provides a reader to convert events to XML node objects into a
	 * {XmlDomStream.Context}.
	 */
	- class SaxToDomHandle : XmlSaxHandle {
		/**
		 * Creates a new writer on the context given by `context`.
		 */
		const def new(self, context) {
			self.context = context
			return self
		}

		/**
		 * Creates a new {XmlDomDocument} node into the context. Returns `true`
		 * to continue input stream parsing.
		 */
		const def onStartDocument(self) {
			self.context.document = XmlDomDocument()
			self.context.elements.clear()
			return true
		}

		/**
		 * Finalize the {XmlDomDocument} node of the context. Returns `true`
		 * if all the elements were correctly closed to continue input stream
		 * parsing; otherwise returns `false`.
		 */
		const def onEndDocument(self) {
			return self.context.elements.isEmpty()
		}

		/**
		 * Creates a new {XmlDomElement} node and push it in the context.
		 * Returns `true` to continue input stream parsing.
		 */
		const def onStartElement(self, name, attributes) {
			self.context.pushElement(XmlDomElement(name, attributes))
			return true
		}

		/**
		 * Finalize the last pushed {XmlDomElement} of the context. Returns
		 * `true` if the closed element match the last pushed element to
		 * continue input stream parsing; otherwise returns `false`.
		 */
		const def onEndElement(self, name) {
			
			var node = self.context.popElement()

			if name == node.getName() {
				if var parent = self.context.topParent() {
					parent.append(node)
					return true
				}
			}

			return false
		}

		/**
		 * Creates a new {XmlDomProcessingInstruction} node into the context.
		 * Returns `true` if the node was correctly inserted into the context
		 * to continue input stream parsing; otherwise returns `false`.
		 */
		const def onProcessingInstruction(self, name, attributes) {

			var node = XmlDomProcessingInstruction(name, attributes)
			
			if var parent = self.context.topParent() {
				parent.append(node)
				return true
			}

			return false
		}

		/**
		 * Creates a new {XmlDomText} node into the context. Returns `true` if
		 * the node was correctly inserted into the context to continue input
		 * stream parsing; otherwise returns `false`.
		 */
		const def onCharacters(self, content) {
			
			var node = XmlDomText(content)
			
			if var parent = self.context.topParent() {
				parent.append(node)
				return true
			}

			return false
		}

		/**
		 * Creates a new {XmlDomComment} node into the context. Returns `true`
		 * if the node was correctly inserted into the context to continue input
		 * stream parsing; otherwise returns `false`.
		 */
		const def onComment(self, content) {

			var node = XmlDomComment(content)
			
			if var parent = self.context.topParent() {
				parent.append(node)
				return true
			}

			return false
		}

		/**
		 * Creates a new {XmlDomCData} node into the context. Returns `true`
		 * if the node was correctly inserted into the context to continue input
		 * stream parsing; otherwise returns `false`.
		 */
		const def onCData(self, content) {

			var node = XmlDomCData(content)
			
			if var parent = self.context.topParent() {
				parent.append(node)
				return true
			}

			return false
		}

		/**
		 * Creates a new {XmlDomDtd} node into the context. Returns `true` if
		 * the node was correctly inserted into the context to continue input
		 * stream parsing; otherwise returns `false`.
		 */
		const def onDtd(self, content) {

			var node = XmlDomDtd(content)
			
			if var parent = self.context.topParent() {
				parent.append(node)
				return true
			}

			return false
		}

		/// Internal context object.
		- context = null
	}

	/// Internal context object.
	- context = null
}

/**
 * This class represents the entire XML document. Conceptually, it is the root
 * of the document tree, and provides the primary access to the document's data.
 */
class XmlDomDocument {
	/**
	 * Returns the first child {XmlDomElement} with a name that match `name` or
	 * `none` if no top level node match.
	 */
	const def findFirstChildElement(const self, name) {
		for var node in self.children {
			if typeof node == 'XmlDomElement' and name == node.getName() {
				return node
			}
		}
	}

	/**
	 * Returns an iterator on each top level child {XmlDomElement} with a name
	 * that match `name`.
	 */
	const def findChildrenElements(const self, name) {
		for var node in self.children {
			if typeof node == 'XmlDomElement' and name == node.getName() {
				yield node
			}
		}
	}

	/**
	 * Returns the index of the node `node` if contained in the document;
	 * otherwise returns `none`. Searching forward from index position `0`.
	 */
	const def indexOf(const self, node) {
		return self.children.indexOf(node)
	}

	/**
	 * Returns the index of the node `node` if contained in the document;
	 * otherwise returns `none`. Searching forward from index position `from`.
	 */
	const def indexOf(const self, node, from) {
		return self.children.indexOf(node, from)
	}

	/**
	 * Returns the index of the node `node` if contained in the document;
	 * otherwise returns `none`. Searching backward from the end of the
	 * document.
	 */
	const def lastIndexOf(const self, node) {
		return self.children.lastIndexOf(node)
	}

	/**
	 * Returns the index of the node `node` if contained in the document;
	 * otherwise returns `none`. Searching backward from index position `from`.
	 */
	const def lastIndexOf(const self, node, from) {
		return self.children.lastIndexOf(node, from)
	}

	/**
	 * Inserts the node `node` at the index given by `index`. If `index` is
	 * negative, the position is relative to the end of the document.
	 */
	const def insert(self, index, node) {
		if index < 0 {
			index = self.values.size() + index
		}
		if index == 0 {
			self.children = [node] + self.children
		} elif index == self.values.size() {
			self.children << node
		} else {
			self.children = self.children[0...index] + node + self.children[index...self.children.size()]
		}
	}

	/**
	 * Appends `node` at the end of the document.
	 */
	const def append(self, node) {
		self.children << node
	}

	/**
	 * Removes `node` from the document.
	 */
	const def remove(self, node) {
		if isDefined(var index = self.children.indexOf(node)) {
			self.children.remove(index)
		}
	}

	/**
	 * Returns `true` if the document contains `node`; otherwise returns
	 * `false`.
	 */
	const def in(const self, const node) {
		if node in self.children {
			return true
		}
		for var child in self.children {
			if node in child {
				return true
			}
		}
		return false
	}

	/**
	 * Returns an iterator on each top level nodes of the document.
	 */
	const def in(const self) {
		for var node in self.children {
			yield node
		}
	}

	/**
	 * Returns an iterator on each top level {XmlDomProcessingInstruction} of the
	 * document.
	 */
	const def processingInstructions(const self) {
		for var node in self.children {
			if typeof node == 'XmlDomProcessingInstruction' {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each top level {XmlDomDtd} of the document.
	 */
	const def doctypes(const self) {
		for var node in self.children {
			if typeof node == 'XmlDomDtd' {
				yield node
			}
		}
	}

	/**
	 * Returns an iterator on each top level {XmlDomElement} of the document.
	 */
	const def elements(const self) {
		for var node in self.children {
			if typeof node == 'XmlDomElement' {
				yield node
			}
		}
	}

	/**
	 * Returns the number of top level nodes in the document.
	 */
	const def size(const self) {
		return self.children.size()
	}

	/**
	 * Returns `true` if the document is empty; otherwise returns `false`.
	 */
	const def isEmpty(const self) {
		return self.children.isEmpty()
	}

	/**
	 * Resets the document.
	 */
	const def clear(self) {
		return self.children.clear()
	}

	/**
	 * Returns the string representation of the document.
	 */
	const def toString(const self) {
		var str = ''
		for var child in self.children {
			str << child.toString()
		}
		return str
	}

	/// Internal child node list.
	- children = []
}

/**
 * This class represents one element in the DOM tree. An element have a tag name
 * and zero or more attributes. It can also contains children nodes.
 */
class XmlDomElement {
	/**
	 * Creates a new element with the given `name` tag name. If `attributes` is
	 * specified, it provides the attributes of the element.
	 */
	const def new(self, name, attributes = {}) {
		self.name = name
		self.attributes = attributes
		return self
	}

	/**
	 * Returns the tag name of the element.
	 */
	const def getName(const self) {
		return self.name
	}

	/**
	 * Sets the tag name of the element.
	 */
	const def setName(self, name) {
		self.name = name
	}

	/**
	 * Returns an hash containing each attributes of the element.
	 */
	const def getAttributes(const self) {
		return self.attributes
	}

	/**
	 * Resets the element attributes.
	 */
	const def clearAttributes(self) {
		self.attributes.clear()
	}

	/**
	 * Returns the attribute called `name`. If the attribute does not exist
	 * `default_value` is returned.
	 */
	const def getAttribute(const self, name, default_value = none) {
		return self.attributes.get(name, default_value)
	}

	/**
	 * Adds an attribute called `name` with value `value`. If an attribute with
	 * the same name exists, its value is replaced by `value`.
	 */
	const def setAttribute(self, name, value) {
		self.attributes[name] = value
	}

	/**
	 * Returns `true` if this element has an attribute called `name`; otherwise
	 * returns `false`.
	 */
	const def hasAttribute(const self, name) {
		return self.attributes.in(name)
	}

	/**
	 * Removes the attribute called `name` from this element.
	 */
	const def removeAttribute(self, name) {
		self.attributes.remove(name)
	}

	/**
	 * Returns the first child {XmlDomElement} with a name that match `name` or
	 * `none` if no direct child node match.
	 */
	const def findFirstChildElement(const self, name) {
		for var node in self.children {
			if typeof node == 'XmlDomElement' and name == node.getName() {
				return node
			}
		}
	}

	/**
	 * Returns an iterator on each direct child {XmlDomElement} with a name that
	 * match `name`.
	 */
	const def findChildrenElements(const self, name) {
		for var node in self.children {
			if typeof node == 'XmlDomElement' and name == node.getName() {
				yield node
			}
		}
	}

	/**
	 * Returns the index of the node `node` if contained in the element;
	 * otherwise returns `none`. Searching forward from index position `0`.
	 */
	const def indexOf(const self, node) {
		return self.children.indexOf(node)
	}

	/**
	 * Returns the index of the node `node` if contained in the element;
	 * otherwise returns `none`. Searching forward from index position `from`.
	 */
	const def indexOf(const self, node, from) {
		return self.children.indexOf(node, from)
	}

	/**
	 * Returns the index of the node `node` if contained in the element;
	 * otherwise returns `none`. Searching backward from the end of the
	 * element.
	 */
	const def lastIndexOf(const self, node) {
		return self.children.lastIndexOf(node)
	}

	/**
	 * Returns the index of the node `node` if contained in the element;
	 * otherwise returns `none`. Searching backward from index position `from`.
	 */
	const def lastIndexOf(const self, node, from) {
		return self.children.lastIndexOf(node, from)
	}

	/**
	 * Inserts the node `node` at the index given by `index`. If `index` is
	 * negative, the position is relative to the end of the element.
	 */
	const def insert(self, index, node) {
		if index < 0 {
			index = self.values.size() + index
		}
		if index == 0 {
			self.children = [node] + self.children
		} elif index == self.values.size() {
			self.children << node
		} else {
			self.children = self.children[0...index] + node + self.children[index...self.children.size()]
		}
	}

	/**
	 * Appends `node` at the end of the element.
	 */
	const def append(self, node) {
		self.children << node
	}

	/**
	 * Removes `node` from the element.
	 */
	const def remove(self, node) {
		if isDefined(var index = self.children.indexOf(node)) {
			self.children.remove(index)
		}
	}

	/**
	 * Returns `true` if the element contains `node`; otherwise returns
	 * `false`.
	 */
	const def in(const self, const node) {
		if node in self.children {
			return true
		}
		for var child in self.children {
			if node in child {
				return true
			}
		}
		return false
	}

	/**
	 * Returns an iterator on each direct children nodes of the element.
	 */
	const def in(const self) {
		for var node in self.children {
			yield node
		}
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the number of direct children nodes in the element.
	 */
	const def size(const self) {
		return self.children.size()
	}

	/**
	 * Returns `true` if the element is empty; otherwise returns `false`.
	 */
	const def isEmpty(const self) {
		return self.children.isEmpty()
	}

	/**
	 * Resets the element.
	 */
	const def clear(self) {
		return self.children.clear()
	}

	/**
	 * Returns the string representation of the element.
	 */
	const def toString(const self) {
		
		if self.children.isEmpty() {
			return '<%s%s/>' % (self.name, self.attributesToString())
		}

		var str = '<%s%s>' % (self.name, self.attributesToString())
		for var child in self.children {
			str << child.toString()
		}
		str << '</%s>' % self.name
		return str
	}

	/**
	 * Returns the string representation of the attribute list of the element.
	 */
	- const def attributesToString(const self) {
		var str = ''
		for var name, var value in self.attributes {
			str << ' %s="%s"' % (name, XmlSaxStream.escapeString(value))
		}
		return str
	}

	/// Internal tag name.
	- name = ''

	/// Internal attributes list.
	- attributes = {}

	/// Internal child node list.
	- children = []
}

/**
 * This class represents an XML processing instruction. A processing instruction
 * have a target name and one or more ettributes.
 */
class XmlDomProcessingInstruction {
	/**
	 * Creates a new processing instruction with the given `name` target name
	 * and `attributes` attribute list.
	 */
	const def new(self, name, attributes) {
		self.name = name
		self.attributes = attributes
		return self
	}

	/**
	 * Returns the target name of the processing instruction.
	 */
	const def getName(const self) {
		return self.name
	}

	/**
	 * Sets the target name of the processing instruction.
	 */
	const def setName(self, name) {
		self.name = name
	}

	/**
	 * Returns an hash containing each attributes of the processing instruction.
	 */
	const def getAttributes(const self) {
		return self.attributes
	}

	/**
	 * Resets the processing instruction attributes.
	 */
	const def clearAttributes(self) {
		self.attributes.clear()
	}

	/**
	 * Returns the attribute called `name`. If the attribute does not exist
	 * `default_value` is returned.
	 */
	const def getAttribute(const self, name, default_value = none) {
		return self.attributes.get(name, default_value)
	}

	/**
	 * Adds an attribute called `name` with value `value`. If an attribute with
	 * the same name exists, its value is replaced by `value`.
	 */
	const def setAttribute(self, name, value) {
		self.attributes[name] = value
	}

	/**
	 * Returns `true` if this processing instruction has an attribute called
	 * `name`; otherwise returns `false`.
	 */
	const def hasAttribute(const self, name) {
		return self.attributes.in(name)
	}

	/**
	 * Removes the attribute called `name` from this processing instruction.
	 */
	const def removeAttribute(self, name) {
		self.attributes.remove(name)
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the string representation of the processing instruction.
	 */
	const def toString(const self) {
		return '<?%s%s?>' % (self.name, self.attributesToString())
	}

	/**
	 * Returns the string representation of the attribute list of the processing
	 * instruction.
	 */
	- const def attributesToString(const self) {
		var str = ''
		for var name, var value in self.attributes {
			str = ' %s="%s"' % (name, XmlSaxStream.escapeString(value)) + str
		}
		return str
	}

	/// Internal target name.
	- name = ''

	/// Internal attributes list.
	- attributes = {}
}

/**
 * This class represents text data in the parsed XML document.
 */
class XmlDomText {
	/**
	 * Creates a new text node for the text given by `content`.
	 */
	const def new(self, content) {
		self.content = trim(content)
		return self
	}

	/**
	 * Returns the content of the text node.
	 */
	const def getContent(const self) {
		return self.content
	}

	/**
	 * Sets the content of the text node.
	 */
	const def setContent(self, content) {
		self.content = content
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the string representation of the text node.
	 */
	const def toString(const self) {
		return XmlSaxStream.escapeString(self.content)
	}

	/// Internal content data.
	- content = ''
}

/**
 * This class represents comment data in the parsed XML document.
 */
class XmlDomComment {
	/**
	 * Creates a new comment node for the comment given by `content`.
	 */
	const def new(self, content) {
		self.content = trim(content)
		return self
	}

	/**
	 * Returns the content of the comment node.
	 */
	const def getContent(const self) {
		return self.content
	}

	/**
	 * Sets the content of the comment node.
	 */
	const def setContent(self, content) {
		self.content = content
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the string representation of the comment node.
	 */
	const def toString(const self) {
		return '<!--%s-->' % self.content
	}

	/// Internal content data.
	- content = ''
}

/**
 * This class represents an XML CDATA section.
 * 
 * CDATA sections are used to escape blocks of text containing characters that
 * would otherwise be regarded as markup. The only delimiter that is recognized
 * in a CDATA section is the `]]>` string that terminates the CDATA section.
 * 
 * CDATA sections cannot be nested. Their primary purpose is for including
 * material such as XML fragments, without needing to escape all the delimiters.
 */
class XmlDomCData {
	/**
	 * Creates a new CDATA node for the text given by `content`.
	 */
	const def new(self, content) {
		self.content = trim(content)
		return self
	}

	/**
	 * Returns the content of the CDATA node.
	 */
	const def getContent(const self) {
		return self.content
	}

	/**
	 * Sets the content of the CDATA node.
	 */
	const def setContent(self, content) {
		self.content = content
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the string representation of the CDATA node.
	 */
	const def toString(const self) {
		return '<![CDATA[%s]]>' % self.content
	}

	/// Internal content data.
	- content = ''
}

/**
 * This class is the representation of the DTD in the document tree.
 */
class XmlDomDtd {
	/**
	 * Creates a new DTD node for the text given by `content`.
	 */
	const def new(self, content) {
		self.content = trim(content)
		return self
	}

	/**
	 * Returns `true` if `other` is the same node than `self`; otherwise returns
	 * `false`.
	 */
	const def ==(const self, const other) {
		return self is other
	}

	/**
	 * Returns `false` if `other` is the same node than `self`; otherwise
	 * returns `true`.
	 */
	const def !=(const self, const other) {
		return not (self is other)
	}

	/**
	 * Returns the string representation of the DTD node.
	 */
	const def toString(const self) {
		return '<!DOCTYPE %s>' % self.content
	}

	/// Internal content data.
	- content = ''
}
