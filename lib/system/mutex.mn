/**
 * This module provides the {System.Mutex} class which provides access
 * serialization between threads.
 */

package System {

	/**
	 * This class protect an object, data structure or section of code so that
	 * only one thread can access it at a time. The purpose of this class is to
	 * be used with instances of {System.Thread} to synchronize two or more
	 * threads.
	 * 
	 * The {LockGuard} class can be used to ensure that the mutex is correctly
	 * locked and unlocked by a section of code.
	 */
	class Mutex {
		/**
		 * This enum describe the behavior of the mutex.
		 */
		enum Type {
			/**
			 * Normal mutex must be unlocked before an other lock is performed.
			 * If the thread try to relock an already locked normal mutex, the
			 * mutex will deadlock.
			 */
			Normal
			/**
			 * Recursive mutex can be locked recursively by the same thread but
			 * must be unlocked the same amount of times to allow other threads
			 * to lock it.
			 */
			Recursive
		}

		/**
		 * Creates a new mutex. The `type` parameter describe the behavior of
		 * the mutex an must be an instance of {System.Mutex.Type}.
		 */
		const def new(self, type = System.Mutex.Type.Normal) {
			self.d_ptr = Mutex.g_lib.call('mint_mutex_create', type)
			self.d_ptr.delete = def [g_lib = System.Mutex.g_lib] (self) {
				g_lib.call('mint_mutex_delete', self)
			}
			return self
		}

		/**
		 * Locks the mutex. If another thread has locked the mutex then this
		 * call will block until that thread has unlocked it.
		 * 
		 * If the mutex use the `System.Mutex.Type.Recursive` behavior, this
		 * method can be called multiple times in the same thread; otherwise
		 * multiple calls will cause a dead-lock.
		 */
		const def lock(self) {
			Mutex.g_lib.call('mint_mutex_lock', self.d_ptr)
		}

		/**
		 * Unlocks the mutex. Attempting to unlock a mutex in a different thread
		 * to the one that locked it results in an error. Unlocking a mutex that
		 * is not locked results in undefined behavior.
		 */
		const def unlock(self) {
			Mutex.g_lib.call('mint_mutex_unlock', self.d_ptr)
		}

		/**
		 * Attempts to {@see lock} the mutex. This function returns `true` if
		 * the lock was obtained; otherwise it returns `false`.
		 */
		const def tryLock(self) {
			return Mutex.g_lib.call('mint_mutex_try_lock', self.d_ptr)
		}

		/**
		 * Returns the behavior of this mutex.
		 */
		const def getType(const self) {
			return Mutex.g_lib.call('mint_mutex_get_type', self.d_ptr)
		}

		/// Global library handle.
		- @g_lib = lib('libmint-system')

		/// Object data.
		- d_ptr = null
	}
}
