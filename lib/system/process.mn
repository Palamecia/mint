load mint.type
load event.pipe
load system.directory

package System {

	class Process {
		def new(self, ident) {
			switch typeof ident {
			case 'number':
				self.handle = Process.g_lib.call('mint_process_get_handle', ident)
				(self.command, self.args) := Process.g_lib.call('mint_process_getcmdline', self.handle)
				self.workingDirectory = System.Directory(Process.g_lib.call('mint_process_getcwd', self.handle))
				self.environement = Process.g_lib.call('mint_process_getenv', self.handle)
				break

			case 'System.Process':
				return ident

			default:
				if defined ident.toProcess {
					return ident.toProcess()
				}

				self.command = string(ident)
				self.workingDirectory = System.Directory.current()
				break
			}

			return self
		}

		def delete(self) {
			Process.g_lib.call('mint_process_close_handle', self.handle)
		}

		@def list() {
			return Process.g_lib.call('mint_process_list')
		}

		@def current() {
			return Process.g_current
		}

		def getPid(self) {
			return Process.g_lib.call('mint_process_get_pid', self.handle)
		}

		def getCommand(self) {
			return self.command
		}

		def getArguments(self) {
			return self.args
		}

		def getWorkingDirectory(self) {
			return self.workingDirectory
		}

		def setWorkingDirectory(self, workingDirectory) {
			self.workingDirectory = System.Directory(workingDirectory)
		}

		def getEnvironement(self) {
			return self.environement
		}

		def setEnvironement(self, environement) {
			self.environement = environement
		}

		def isRunning(self) {
			if defined self.handle {
				if Process.g_lib.call('mint_process_waitpid', self.handle, false, self.exit_status, self.exit_code) {
					self.handle = none
					return false
				}
				return true
			}
			return false
		}

		def exec(self, ...) {
			if self.start(*va_args) {
				return self.wait()
			}
			return false
		}

		def start(self, ...) {
			if not defined self.handle {
				handleset = []
				self.pipes = []
				for i in 0...3 {
					pipe = Event.Pipe()
					self.pipes << pipe
					handleset << [pipe.getReadHandle(), pipe.getWriteHandle()]
				}
				self.args = array(va_args)
				self.handle = Process.g_lib.call('mint_process_start', self.command, self.args, self.workingDirectory.getPath(), self.environement, handleset)
				if defined self.handle {
					self.workingDirectory = System.Directory(Process.g_lib.call('mint_process_getcwd', self.handle))
					self.environement = Process.g_lib.call('mint_process_getenv', self.handle)
					return true
				}
			}
			return false
		}

		def wait(self) {
			if defined self.handle {
				if Process.g_lib.call('mint_process_waitpid', self.handle, true, self.exit_status, self.exit_code) {
					self.handle = none
					return true
				}
			}
			return false
		}

		def kill(self) {
			if defined self.handle {
				return Process.g_lib.call('mint_process_kill', self.handle)
			}
			return false
		}

		def treminate(self) {
			if defined self.handle {
				return Process.g_lib.call('mint_process_treminate', self.handle)
			}
			return false
		}

		def exitStatus(self) {
			return self.exit_status
		}

		def exitCode(self) {
			return self.exit_code
		}

		def write(self, data) {
			return self.pipes[0].write(data)
		}

		def read(self) {
			return self.pipes[1].read()
		}

		def readError(self) {
			return self.pipes[2].read()
		}

		- @g_lib = lib('libmint-system')
		- @g_current = none
		- command = ''
		- args = []
		- workingDirectory = null
		- environement = none
		- pipes = []
		- handle = none
		- exit_status = true
		- exit_code = 0
	}

	/*!
	* @brief
	*/
	def [g_lib = lib('libmint-system')] exec(command) {
		return g_lib.call('mint_process_exec', command)
	}

	/*!
	* @brief
	*/
	def [g_lib = lib('libmint-system')] getpid() {
		return g_lib.call('mint_process_getpid')
	}

	Process.g_current = Process(getpid())
}
