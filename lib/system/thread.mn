/**
 * This module provides classes and functions to create multi-threaded
 * applications.
 */

package System {

	/**
	 * This class manages one thread of control within the script. A thread can
	 * be associated with any function or object methode that will be executed
	 * alongside the other threads by calling the {@see start} method. Once
	 * started, the thread will continue until the end of the function.
	 */
	class Thread {
		/**
		 * Creates a new thread that will execute the `func` function.
		 */
		const def new(self, func) {
			self.function = func
			return self
		}

		/**
		 * Creates a new thread that will execute the `func` methode of object
		 * `obj`.
		 */
		const def new(self, obj, func) {
			self.object = obj
			self.function = func
			return self
		}

		/**
		 * Waites the end of the called function before object destruction.
		 */
		const def delete(self) {
			if defined self.id and self.started and self.id != Thread.current().getId() {
				self.join()
			}
		}

		/**
		 * Returns an instance of {System.Thread} for the current thread.
		 */
		@const def current() {
			var thread = Thread(none)
			thread.id = System.Thread.g_lib.call('mint_thread_current_id')
			return thread
		}

		/**
		 * Starts the associated function in a new thread. The parameters passed
		 * to this method are forwarded to the called function.
		 * 
		 * Returns `true` if the thread was effectively started; otherwise returs
		 * `false`. The object must not be already running a joinable thread.
		 */
		const def start(self, ...) {
			if defined self.function and not self.isJoinable() {
				if defined self.object {
					self.id = System.Thread.g_lib.call('mint_thread_start_member', self.object, self.function, va_args)
				} else {
					self.id = System.Thread.g_lib.call('mint_thread_start', self.function, va_args)
				}
				if defined self.id {
					self.started = true
					return true
				}
			}
			return false
		}

		/**
		 * Returns the thread-id of the object thread or `none` if not started.
		 */
		const def getId(const self) {
			return self.id
		}

		/**
		 * Returns `true` if the thread is joinable; otherwise returs `false`.
		 */
		const def isJoinable(const self) {
			if defined self.id {
				return System.Thread.g_lib.call('mint_thread_is_joinable', self.id)
			}
			return false
		}

		/**
		 * Waites for the thread to finish.
		 */
		const def join(self) {
			if defined self.id {
				System.Thread.g_lib.call('mint_thread_join', self.id)
			}
		}

		/// Global library handle.
		- @g_lib = lib('libmint-system')

		/// Internal thread id.
		- id = none

		/// Internal associated object.
		- object = none

		/// Internal associated function.
		- function = null

		/// Internal started state.
		- started = false
	}

	/**
	 * Yields execution of the current thread to another runnable thread, if any.
	 * Note that the operating system decides to which thread to switch.
	 */
	def [g_lib = lib('libmint-system')] wait() {
		return g_lib.call('mint_thread_wait')
	}

	/**
	 * Forces the current thread to sleep for `time` milliseconds.
	 */
	def [g_lib = lib('libmint-system')] sleep(time) {
		return g_lib.call('mint_thread_sleep', time)
	}
}
